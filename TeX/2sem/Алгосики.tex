\documentclass{book}
%nerd stuff here
\pdfminorversion=7
\pdfsuppresswarningpagegroup=1
% Languages support
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
% Some fancy symbols
\usepackage{textcomp}
\usepackage{stmaryrd}
% Math packages
\usepackage{amsmath, amssymb, amsthm, amsfonts, mathrsfs, dsfont, mathtools}
\usepackage{cancel}
% Bold math
\usepackage{bm}
% Resizing
%\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
% Optional font for not math-based subjects
%\usepackage{cmbright}

\author{Коченюк Анатолий}
\title{Конспект~по~алгоритмам~и~структурам~данных\\ II семестр}

\usepackage{url}
% Fancier tables and lists
\usepackage{booktabs}
\usepackage{enumitem}
% Don't indent paragraphs, leave some space between them
\usepackage{parskip}
% Hide page number when page is empty
\usepackage{emptypage}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{myStyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=myStyle}

\lstset{language=Python}
\usepackage{float}
% Some shortcuts
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\R{\ensuremath{\mathbb{R}}}
\newcommand\Z{\ensuremath{\mathbb{Z}}}
\renewcommand\O{\ensuremath{\emptyset}}
\newcommand\Q{\ensuremath{\mathbb{Q}}}
\renewcommand\C{\ensuremath{\mathbb{C}}}
\newcommand{\p}[1]{#1^{\prime}}
\newcommand{\pp}[1]{#1^{\prime\prime}}
% Easily typeset systems of equations (French package) [like cases, but it aligns everything]
\usepackage{systeme}
\usepackage{lipsum}
% limits are put below (optional for int)
\let\svlim\lim\def\lim{\svlim\limits}
\let\svsum\sum\def\sum{\svsum\limits}
%\let\svlim\int\def\int{\svlim\limits}
% Command for short corrections
% Usage: 1+1=\correct{3}{2}
\definecolor{correct}{HTML}{009900}
\newcommand\correct[2]{\ensuremath{\:}{\color{red}{#1}}\ensuremath{\to }{\color{correct}{#2}}\ensuremath{\:}}
\newcommand\green[1]{{\color{correct}{#1}}}
% Hide parts
\newcommand\hide[1]{}
% si unitx
\usepackage{siunitx}
\sisetup{locale = FR}
% Environments
% For box around Definition, Theorem, \ldots
\usepackage{mdframed}
\mdfsetup{skipabove=1em,skipbelow=0em}
\theoremstyle{definition}
\newmdtheoremenv[nobreak=true]{definition}{Определение}
\newmdtheoremenv[nobreak=true]{theorem}{Теорема}
\newmdtheoremenv[nobreak=true]{lemma}{Лемма}
\newmdtheoremenv[nobreak=true]{problem}{Задача}
\newmdtheoremenv[nobreak=true]{property}{Свойство}
\newmdtheoremenv[nobreak=true]{statement}{Утверждение}
\newmdtheoremenv[nobreak=true]{corollary}{Следствие}
\newmdtheoremenv[nobreak=true]{remember}{Воспоминание}
\newtheorem*{note}{Замечание}
\newtheorem*{example}{Пример}
\renewcommand\qedsymbol{$\blacksquare$}
\newcommand{\ov}[2]{\overset{#1}{#2}}
\newcommand{\tl}[1]{\widetilde{#1}}
% Fix some spacing
% http://tex.stackexchange.com/questions/22119/how-can-i-change-the-spacing-before-theorems-with-amsthm
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=\parskip \thm@postskip=0pt
}
\usepackage{xifthen}
\def\testdateparts#1{\dateparts#1\relax}
\def\dateparts#1 #2 #3 #4 #5\relax{
    \marginpar{\small\textsf{\mbox{#1 #2 #3 #5}}}
}

\def\@lecture{}%
\newcommand{\lecture}[3]{
    \ifthenelse{\isempty{#3}}{%
        \def\@lecture{Lecture #1}%
    }{%
        \def\@lecture{Lecture #1: #3}%
    }%
    \subsection*{\@lecture}
    \marginpar{\small\textsf{\mbox{#2}}}
}
% Todonotes and inline notes in fancy boxes
\usepackage{todonotes}
\usepackage{tcolorbox}

% Make boxes breakable
\tcbuselibrary{breakable}
\newenvironment{correction}{\begin{tcolorbox}[
    arc=0mm,
    colback=white,
    colframe=green!60!black,
    title=Correction,
    fonttitle=\sffamily,
    breakable
]}{\end{tcolorbox}}
% These are the fancy headers
\usepackage{fancyhdr}
\pagestyle{fancy}

% LE: left even
% RO: right odd
% CE, CO: center even, center odd
% My name for when I print my lecture notes to use for an open book exam.
% \fancyhead[LE,RO]{Gilles Castel}

\fancyhead[RO,LE]{\@lecture} % Right odd,  Left even
\fancyhead[RE,LO]{}          % Right even, Left odd

\fancyfoot[RO,LE]{\thepage}  % Right odd,something additional 1  Left even
\fancyfoot[RE,LO]{}          % Right even, Left odd
\fancyfoot[C]{\leftmark}     % Center

\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\usepackage{tikz}
\begin{document}
    \maketitle
    \chapter{Новые структуры данных}
    \section{Дерево отрезков}

    Segment Tree, Range Tree, Interval Tree -- можно наткнутся на другие структуры

    Есть массив $a$ на  $n$ элементов
     \begin{enumerate}
         \item set(i,v) $\quad a[i] = v$
         \item sum(l,r)  $\quad \sum_{i=l}^{r-1} a[i]$
    \end{enumerate}

    $\left[ 3,5,2,1,6,4,8,3 \right] $

    Построим дерево, где в каждом узле сумма двух под ним. Каждое число это сумма чисел на каком--то отрезке.

    Заменим 4 на 7. set(5, 7). Нужно пересчитать все узлы, которые выше него. Их логарифм.

    Теперь к сумме. Сумму от  $l $ до  $r$ мы будем раскладывать на суммы, которые мы уже знаем.
     \begin{enumerate}
        \item Как найти эти суммы: обойдём наше дерево рекурсивно, не заходя в плохие поддереве. Идём вниз: если в поддереве нет нужных элементов, выходим, если полностью содержится в нужном, берём эту сумму, иначе идём дальше вниз.
        \item Мы обошли не так много (порядка логарифма) узлов. Посмотрим на узлы, в которых не сработало отсечение. Тогда наш отрезок содержит одну из границ отрезка. Отрезков, которые содержат границу (правую или левую) не более $2\log n$. 

            Запуск рекурсии: узлов, в которых не сработало отсечение -- $2\log n$, всего узлов $\approx 4\log n$.
    \end{enumerate}

    Будем хранить полное двоичное дерево. У узла $i$ дети  $2i+1$ и  $2i+2$

    \begin{verbatim}
        set(i, v, x, lx, rx):
            if rx - lx = 1:
                tree[x] = v
            else:
                m = (lx+rx)/2
                if i < m:
                    set(i,v,2x+1,lx,m)
                else:
                    set(i,v,2x+2,m, rx)
                tree[x] = tree[2x+1] + tree[2x+2]

        sum(l, r, x, lx, rx):
            if l >= rx || lx >= r:
                return 0
            if lx >= l && rx <= r:
                return tree[x]
            m = (lx+rx)/2
            s1 = sum(l, r, 2x+1, lx, m)
            s2 = sum(l, r, 2x+2, m, rx)
            return s1 + s2
    \end{verbatim}

    Пусть мы теперь хотим посчитать минимум. Делаем то же самое, только в каждом узле храним не сумму на отрезке, а минимум. Только в случае пустого дерева вместо 0 в сумме надо вернуть $+\infty $ (нейтральный элемент по операции)

    Если нужно сделать операцию $a \bigotimes b$. Если у неё есть ассоциативность  $(a\otimes b)\otimes c = a\otimes (b\otimes c)$, то её можно встроить в дерево отрезков. 

$max, +, \cdot , \&, |, \text{НОД}, \text{НОК}$ 

\subsection{Снизу вверх}

Занумеруем также, но будем идти снизу вверх и без рекурсии.

\begin{verbatim}
    set(i, v): // n = 2^k
        x = i + n - 1
        delta = v - tree[x]
        while x >= 0:
            tree[x]+=delta
            x = (x+1)/2-1

    sum(l, r):
        l = n-1+r
        r = n-2+r
        res = 0
        while r >= l:
            if l % 2 = 0:
                res += tree[l]
            l = l / 2
            if r % 2 = 1:
                res += tree[r]
            r = r/2-1
        return res
\end{verbatim}

Если нужно посчитать другую функцию, поменяется нейтральный элемент. Если не коммутативная функцию, можно сначала считать левую, потом правую, а потом их сложить.

Такая реализация чуть лучше работает как $o(\log (l-r))$. Каждый раз разница между $ l$ и $r$ уменьшается в 2 раза.  

\section{Персистентное дерево отрезков}

$\begin{array}{c}
     15\\ 8 ~ ~ ~7\\ 3~5~6~1
 \end{array}
$

set(2,8) Сделаем новый узел рядом с 6. Рядом с узлом 7 на верхнем слое приделаем ещё один узел 9. А к корню приделаем узел 17. Так у нас появилось две параллельные версия дерева отрезков.
 

\section{Дерево отрезков v.2}

Теперь мы хотим:
\begin{enumerate}
    \item $add(l, r, v)\quad a[i]+=v\quad i = l \ldots r-1$
    \item $get(i)\quad return~a[i]$
\end{enumerate}

Построим дерево отрезков над массивом как в прошлый раз. В начале везде запишем нолики. Хотим добавить 3 к отрезку. Разобъём его на кусочки и в верхние узлы над нужным отрезком запишем тройки.

\begin{verbatim}
    add(l, r, v, x, lx, rx):
        if (lx >= r) || (l >= rx):
            return
        if lx >= l && rx <= r:
            tree[x] += v
            return
        m = (lx+rx)/2
        add(l, r, v, 2x+1, lx, m)
        add(l, r, v, 2x+2, m, rx)
\end{verbatim}

Сделаем $modify(l, r, v)\quad a[i] = a[i]\bigstar  v $, где $\bigstar $ ассоциативно и коммутативно.

Как жить с некоммутативными операциями? Записывать порядок. Точнее при получении значения пропихиваем верхние значения вниз справа.

\begin{verbatim}
    propogate(x):
        tree[2x+1]+=tree[x]
        tree[2x+2]+=tree[x]
        tree[x] = 0
\end{verbatim}

\begin{example}
    [Присваивание]
    set -- задаёт значение на отрезке. код такой же
    \begin{verbatim}
    propogate(x):
        if tree[x] != NO_OPERATION
    \end{verbatim}
\end{example}


Теперь сделаем две операции: прибавление и минимум, оба на отрезке.

Сначала сделаем дерево на минимум. Дальше при добавлении находим нужные отрезки и запоминаем, что нужно добавить 3 в узлах. минимумы снизу мы пересчитывать не будем

Когда доходим до узла добавляем v  в два массива: добавочный и минимумов + обвнояляем минимум, при спуске: $tm[x] = min(tm[2x+1], tm[2x+2]) + ta[x]$

\begin{verbatim}
    propogate

    min(l, r, x, lx, rx):
        ...
        ...
        ...
        s1 = min(l, r, 2x+1, lx, m)
        s2 = min(l, r, 2x+2, m, rx)
        return min(s1,s2) + ta[x]
\end{verbatim}

Здесь мы пользовались дистрибутивностью при пересчёте.
На самом деле, можно для недистрибутивных (например двух плюсов) сделать её такой, или помнить как именно нужно изменить

\section{Дерево Фенвика}

\begin{problem}
    Есть массив

    Нужно:
    \begin{enumerate}
        \item inc(i, v) $\quad a[i]=+v$
        \item sum(l,r)  $\quad \sum_{i=l}^{r-1} a[i]$
    \end{enumerate}

    Оба за логарифм
\end{problem}

Казалось бы всё это умеет дерево отрезков.. Но можно лучше! (всё ещё за логарифм, но) 

$f(i) = \sum_{j=p(i)}^{i} a[j]$ 

$sum(l, r) = sum(l) - sum(r)$

Как считается  $sum(i)$:
В последнем элементе лежит какая-то сумма. Добавим её к ответу. В  элементе до этой суммы (префикса) лежит какая-то сумма. Добавим её к ответу... Так, пока не дойдём до начала массива.

inc(i, v): ищем все суммы, содержащие $i$ и увеличиваем их на  $v$ 

По итогу нам нужна хорошая $p(x)$, чтобы и отрезков в  $sum(i)$ было поменьше (логарифм), и отрезков, содержащих  $i$ было тоже логариф.

$x:\quad \max k: (x+1) \vdots 2^k\quad p(x) = x+1-2^k$ (В терминах двоичной записи все единички идущие подряд в конце числа становятся нулями.

$p(x)$ довольно просто найти, это  $x\&(x+1)$

\begin{verbatim}
    sum(l,r):
        return sum(r) - sum(l)

    sum(r):
        x = r - 1
        res = 0
        while x >= 0:
            res += f[x]
            x = (x&(x+1))-1
        return res      
\end{verbatim}

Для инкремента нужно найти все такие $j\quad p(j)\leqslant i\leqslant j$

$j$ -- префикс, 0 и последовательность единиц.  $p(j)$ -- префикс, 0 и последовательность нулей.

Тогда  $i$, между ними, -- префикс, ноль и что-угодно. Соответственно такие $j$ из  $i$ можно получать заменяя последние  $n$ бит числа $i$ на единицы.

 \begin{verbatim}
    inc(i, v):
        j = i
        while (j < n):
            f[j] += v
            j = j | (j+1)

\end{verbatim}


\section{Разреженная таблица}

Хотим. Структуру. Данных.

Задан массив и он не меняется. Хотим посчитать минимум на любом отрезке за 1.

Можем предпосчитать за квадрат на всех отрезках и просто выдавать, но это долго.

$m[i,j] = \min\left( a\left[ i \ldots i+2^j-1 \right]  \right) \qquad i = 0 \ldots n-1\quad j = 0 \ldots \log n$

\begin{verbatim}
     for i = 0 .. n m[i,0] = a[i]
     for j = 1 .. log n
         for i = 0 .. n-2^j
            m[i,j] = min(m[i,j-1], m[i+2^(j-1), j-1])
\end{verbatim}

Теперь собственно как искать минимум:

$d = r-l\quad \max k: 2^k \leqslant  d$

$res = \min\left( m[l,k], m[r-2^k, k] \right) $ 

Нужно искать к-шки за О(1). Вообще с помощью \textit{битовых извращений} можно найти за $\log\log$, а с помощью \textit{страшных битовых извращений} вообще за  $O(1)$, но мы пока не будем выпендриваться  и просто предпосчитаем к-шки для всех  $d$

Ура! всё работает. Но вся эта схема сильно использует тот факт, что мы считаем минимум (использует свойство идемпотентности $min(x,x) = x$). Таких функций не прям чтоб много, а хотелось бы и с другими аналогичные вещи делать.

Давайте поделим отрезок пополам и посчитаем  префиксные cуммы справа и слева от середины. Тогда большой отрезок в запросе можно разбить на два:  до и после середины, сложить (применить функцию) и получить ответ.

Проблема: если отрезок в одной половине, то его в общем случае не посчитать. Решение: поделим половины отрезков так же, как делили целый. В итоге мы найдём $2n$ сумм.  $n$ на всё отрезке и по  $\frac{n}{2}$ на половинах. С каждым таким делением добавляется $n$. Всего делить можем  $\log n$ раз, значит сумм всего будет $n\log n$

Отвечаем на запрос: находим границу, которую отрезок от  $l$ до $r$ пересекает (первый бит числа  $l\& r$)

\section{Чё можно делать в двумерном случае}

\begin{problem}
    Есть прямоугольнички, они пересекаются. Ещё есть набор точек. Для каждой точки надо найти сколько прямоугольников покрывает эту точку
\end{problem}
\begin{proof}
    [Решение]

    Метод заметающей прямой. Поставим прямую и будем двигать её направо. Когда встретим точку, ответим на запрос про неё.

    Для одной линии считаем сколько покрывает каждую точку.

    Выделим все y кординаты, в которых есть вершина прямоугольника. 

    Встретили границу, делаем +=1 или -=1


\end{proof}

\begin{problem}
    Есть прямоугольники. Надо найти площадь их объединения

    Структура:
    \begin{enumerate}
        \item $a[i]\pm 1$ на отрезка
        \item $\sum len(i):a[i]>0$
    \end{enumerate}
\end{problem}


Дерево отрезков:
\begin{enumerate}
    \item sum(i,v)
    \item sum(l,r)
\end{enumerate}

Прямой аналог:
\begin{enumerate}
    \item set(i,j,v) \quad a[i,j] = v
    \item sum(l,r,t,b)
\end{enumerate}

Сделаем дерево отрзков для строчек. Каждая вершина отвечает за полосу из строчек. В каждой вершине хранится дерево отрезков по столбцам.

\section{Дерево Фенвика 2D}

$f(i) = \sum_{j=p(i)}^{i} a[j]$ 

$f(i,j) = \sum_{x=p(i)}^{i} \sum_{y=p(j)}^{j} a[x,y]$ 

План: сделать всё точно также

\begin{verbatim}
    x = i-1
    while x >= 0:
        rest += f(x)
        x = x&(x+1)-1

    x = i
    while x >= 0:
        y = j
        while y >= 0:
            rest += f(x,y)
            y = (y+1)&y-1
        x = (x+1)&x-1
\end{verbatim}

\section{Разреженные таблицы 2D}

$m[i,j] = min\left( a[i,i+a^j-1] \right) $ 

$m[i_1, j_1, i_2, j_2] = min\left( a[i_1, i_1+2^{j_1}-1, i_2, i_2+2^{j_2}-1 \right) $

precalc $O(n^2\lg^2)$

Запрос: $O(1)$

 \begin{problem}
     Есть двумерные точки. Хотим вывести все точки в прямоугольнике.

     Спроектируем точки на одну координату и построим на них дерево отрезков. В вершинах сортированные по другой координате точке. 
 \end{problem}

 \section{Бинпоиск.каскадирование}

 Делаем один и тот же бинпоиск на многих массивах. -- $O\left( n\log m \right) $ 

 Если знать в нашей последней задаче где бинпоиск в корне, можно легко понять как будет в рекурсии, элементы только пропадают и позиции однозначно соответствуют

 \textbf{Частичное каскадирование, Fractional Cascading}

 Чтобы не появлялось много лишних элементов, запихаем массива наверх. Чтобы не было слишком много, запихаем половину (каждый второй).

 При переходе смотрим на ближайшие запихнутые элементы. X между ними, проверем две позиции.

 А теперь у нас много элементов.

 \section{Дерево поиска}

set, map. Что умеет и то, и то? Хэш-таблица
 
add, remove, contains, put(k,v), get(k)

Хотим иметь линейный порядок.  $(x<y)$

Выполняется свойство: Все элементы в левом поддереве элементы меньше узла. Справа -- больше.

\begin{figure}[!ht]
    \centering
    \incfig{tree}
    \caption{$contains(7)\quad add(4)$}
    \label{fig:tree}
\end{figure}



$h$ -- высота дерева. за  $O(h)$ можем получать и проверять на наличие

\begin{figure}[!ht]
    \centering
    \incfig{removing}
    \caption{removing (дерево поиска)}
    \label{fig:removing}
\end{figure}

Поищем что-нибудь. Например lower bound -- $\min y \geqslant x\quad y\in Tree$

Стартуем в корне. Если элемент меньше $x$, идём вправо. Иначе запоминаем и идём влево поискать что-нибудь получше. 

Если дерево -- бамбук, то его высота  $n$. Оптимальное дерево -- бинарное, чтобы  $\log n$ было (меньше не сделать)

\section{АВЛ-дерево}

\begin{figure}[!ht]
    \centering
    \incfig{rotation}
    \caption{rotation}
    \label{fig:rotation}
\end{figure}

$H_1, H_2$ -- высоты поддеревьев (правого и левого) $|H_1-H_2| \leqslant 1$

$H\leqslant c\cdot \lg n$

$n\geqslant 2^{\frac{H}{c}} = \underbrace{\left( 2^{\frac{1}{c}} \right)}_{\alpha}{}^H $

$n\geqslant \alpha^H$

$F(H) = \min$ число вершин в дереве высоты  $H$

$F(H) = 1 + F(H-1) + F(H-2) >2F(H-2)$

$F(H) \geqslant \frac{\sqrt{2}^H}{2} $ 

\begin{statement}
    Если добавить один элемент в дерево, высота любого дерева изменится максимум на 1

\end{statement}
    Было $(H, H+1)$ стало  $(H, H+2)$. Сломалось АВЛ-дерево

Сделаем операцию балансировки.

\begin{definition}
    [RR-поворот]

    Новый элемент добавился в правое поддерево правого поддерева. Крутим ребро $xy$


LL -- аналогично.
\end{definition}
\begin{figure}[!ht]
    \centering
    \incfig{rr}
    \caption{RR}
    \label{fig:rr}
\end{figure}

\begin{definition}
    [RL]


LR также
\end{definition}
\begin{figure}[!ht]
    \scriptsize
    \centering
    \incfig{rl}
    \caption{RL}
    \label{fig:rl}
\end{figure}
\lstset{language=Java}
    
 \begin{lstlisting}
     class Node{
        Node left, right;
        int key;
     }

     rotate(x, y, p) 
        if (y == x.right):
            x.right = y.left
            y.left = x
        else:
            x.left = y.right
            y.right = x
        x.recalc()
        y.recalc()

    recalc():
        H = max(left.H, right.H)+1

    Node add(Node x, Node nw)
        if (x == null)
            return nw
        if nw.key > x.key
            x.right = add(x.right, nw)
            x.recalc()
            y = x.right
            n = x.left.H
            if y.right == h+1:
                rotate(x,y)
                return y
            else if y.leftH = h+1:
                z = y.left
                rotate(y,z)
                rotate(x,z)
                return z
        else:
            x.left = add(x.left, nw)
            x.recalc()
            y = x.left
            h = x.right.H
            if y.left.H = h+1
                rotate(x,y)
                return y
            else if y.right.H == h+1
                z = y.right
                rotate(y,z)
                rotate(x,z)
                return z

 \end{lstlisting}
\begin{statement}
    А это всё тоже персистентным можно делать

    Можно всякие функции считать на отрезке ключей.
\end{statement}

\section{Декартово Дерево}

\begin{enumerate}
    \item split(x). Из дерева делает два дерева, одно в котором все элементы $<x$, второе --  $\geqslant x$
    \item merge(T1, T2). Берёт два дерево, которые соответственно $<x$ и  $\geqslant x$ и склеивает их. 
\end{enumerate}

За $\log n$ научимся делать обе эти операции.

Итак, в каждом узле нашего дерева будет находится два ключа: $x, y$ и выполняется свойство: 
В правом поддереве:  $\left( <x; <y \right) $, в левом -- $\left( >x; < y \right) $

\begin{figure}[!ht]
    \centering
    \incfig{dektree}
    \caption{dektree}
    \label{fig:dektree}
\end{figure}

Если посмотреть на дерево $x$, получится нормальное дерево поиска. Если посмотреть на ключи  $y$, мы получим кучу.

В английском это всё называется Treap = Tree + Heap

$y = rand\left(  \right) \quad E(n) = O\left( \log n \right) $


\begin{figure}[!ht]
    \centering
    \incfig{treapbuilding}
    \caption{treapbuilding}
    \label{fig:treapbuilding}
\end{figure}

Как строить по набору точек на плоскости:
\begin{enumerate}
    \item Находим точку с наибольшим $y$, она, очевидно, корень. 
    \item Дальше всё, что правее неё, лежит в правом поддереве, всё, что левее -- в левом. Соответственно мы рекурскивно находим корни в этих поддеревьях и соединяем их с корнем на предыдущем шаге.
\end{enumerate}

Эта процедура очень похожа на quick sort, по той же причине эта штука делается за логарифм.

\begin{figure}[!ht]
    \centering
    \incfig{split}
    \caption{split}
    \label{fig:split}
\end{figure}

Split(node, x):
\begin{enumerate}
    \item смотрим с какой стороны стоит корень. Так мы можем сразу сделать вывод об одном из поддеревьев
    \item Запускаемся рекурсивно от второго поддерева
    \item Возвращаем пару деревьев (два корня)
\end{enumerate}

\begin{lstlisting}
    split(node, x):
        if node = null:
            return {null, null}
        if node.x < x:
            p = split(node.right, x)
            node.right = p.first
            return {node, p.second}
        else:
            p = split(node.left, x)
            node.left = p.second
            return {p.first, node}
\end{lstlisting}

\begin{figure}[!ht]
    \centering
    \incfig{merge}
    \caption{merge}
    \label{fig:merge}
\end{figure}

Merge(T1, T2):\quad Все узлы первого меньше всех узлов второго
\begin{enumerate}
    \item Определяем кто из двух корней будет итоговым корнем. 
    \item Делаем merge от второго дерева и ближайшего к нему поддерева главного.
    \item Возвращаем корень выбранный на первом шаге
\end{enumerate}

\begin{lstlisting}
    if A = null:
        return B
    if B = null:
        return A
    if A.y > B.y:
        A.right = merge(A.right, B)
        return A
    else:
        B.left = merge(A, B.left)
        return B
\end{lstlisting}

\begin{figure}[!ht]
    \centering
    \incfig{add}
    \caption{add}
    \label{fig:add}
\end{figure}

Add(A, x):
\begin{enumerate}
    \item Сплиттим на до $x$ и после $x$, получается три дерева: эти и с одним элементом -- $x$
    \item Два раза мёрждим, чтобы получить итоговое дерево
    \item Возвращаем результат последнего мёрджа
\end{enumerate}

\begin{lstlisting}
    add(A, node):
        if node.y > A.y:
            p = split(A, node.x)
            node.left = p.first
            node.right = p.second
        if node.x < A.x:
            A.left = add(A.left, node)
        else:
            A.right = add(A.right, node)
        return A

    remove(A, x):
        if A.x = x:
            return merge(A.left, A.right)
        if x < A.x:
            A.left = remove(A.left, x)
        else:
            A.right = remove(A.right, x)
        return A
\end{lstlisting}

На этом всём можно делать действия на отрезке как обычно, в том числе с propogate

Чтобы сделать персистентным, нужно найти все места, где мы присваиваем и не присваивать.
Пример:
\begin{lstlisting}
    Ap.right = merge
    Ap.left = A.left
    return Ap
\end{lstlisting}

такая копия, у которой одна половинка такая же, а другая изменённая

\begin{remember}
    Были списки [G F W O] + [P C Q] = [G F W O P C Q]

    Хотим два списка объектов обеъединять в один список. А также хотим делать сплит по позиции.

    split(3) -> [G F W], [O P C Q]
\end{remember}

План: хранить последовательности в дереве поиска 

\begin{figure}[!ht]
    \centering
    \incfig{exmerge}
    \caption{Пример merge'a}
    \label{fig:exmerge}
\end{figure}

$merge\left( W, Q \right)  \to merge\left( W, P \right) \to merge\left( O, P \right) \to merge\left( O, null \right) $

\begin{figure}[!ht]
    \centering
    \incfig{exsplit}
    \caption{Пример split'а}
    \label{fig:exsplit}
\end{figure}

$split\left( Q, 5 \right)  \to split\left( W, 5 \right)  \to  split\left( P, 2 \right) \to split\left( C, 0 \right) $


\section{Splay дерево}

Нет никаких вариантов, просто дерево. Любое дерево это валидное Splay дерево. Балансируем с помощью магии, о которой дальше

Есть операция $splay(x)$, которое последовательностью поворотов ставит $x$ в корень

\begin{figure}[!ht]
    \centering
    \incfig{splayop}
    \caption{операция Splay}
    \label{fig:splayop}
\end{figure}

Что делать со всеми остальными операциями? Ко всем операция, которые лезут вглубь дерева мы будем в конце приписывать Splay

Хотим доказать, что $\tl T(splay) = O\left( \lg n \right) $, из этого будет следовать, что и $\tl T(find) = \lg n$

\begin{figure}[!ht]
    \centering
    \incfig{zigop}
    \caption{Операция zig}
    \label{fig:zigop}
\end{figure}

\begin{figure}[!ht]
    \centering
    \incfig{zigzag-zigzig}
    \caption{zigzag-zigzig}
    \label{fig:zigzag-zigzig}
\end{figure}

Вот и весь алгоритм. Давайте ещё раз:
\begin{enumerate}
    \item Есть путь до $x$ и мы хотим сделать операцию  $splay$
    \item Смотрим на два уровня вверх от  $x$ и применяем  zig-zig или zig-zag соответственно
    \item Если остаётся только один родитель, делаем zig
\end{enumerate}

$T(find) = 2 T(splay)$

$\tl T(splay) = O\left( \log n \right)$

$\sum T(splay) \leqslant k \log n \implies \sum T(find) \leqslant 2k\log n \implies \tl T(find) = O(\log n)$

Слейтор, Тарьян. Доказывать амортищированные оценки будем с помощью метода потенциалов.

$\Phi$ -- потенциал  $\geqslant 0\qquad \tl T = T+\underbrace{\Delta\Phi}_{\geqslant 0} \geqslant \sum T$

Потенциал здесь -- мера того насколько дерево плохое. Хотим такой потенциал, чтобы  $\tl T = O\left( \log  n \right) $

$w(x)$ -- вес узла  $x$.  $w(x) = 1$ пока что все веса единицы

$s(x)$ -- суммарный вес поддерева  $x$

$r(x) = \log _2 s(x)$

$\Phi = \sum r(x)$

\begin{figure}[!ht]
    \centering
    \incfig{dokvo-splay}
    \caption{proof-splay}
    \label{fig:proof-splay}
\end{figure}

$\Phi \approx 8.6\qquad \Phi = \approx 15.3$

$\tl T(splay(x)) \leqslant 1+3\left( r'(x) - r(x) \right) $
 
Доказать это -- весь план

\begin{itemize}
    \item [zig] $\tl T \leqslant  1 + 3\left( \p r(x) - r(x) \right) $
    \item [zig-zag, zig-zig]  $\tl T \leqslant 3\left( \p r(x) - r(x) \right) $
\end{itemize}

Если сложить последовательность применений этих команд получится $3(r_2-r_1) + 3\left( r_3-r_2 \right)  + \ldots + 3\left( r_{n-1} - r_{n-2} \right) +1 + 3\left( r_n - r_{n-1} \right)  = 1 + 3\left( r_n-r_1 \right) $

\begin{note}
    Единицы в сумме может не оказаться hence знак $\leqslant $
\end{note}

\begin{proof}
    \begin{itemize}
        \item []
        \item [zig] $\tl T = \overbrace{T}^{=1} + \Delta \Phi = 1 + \cancel{\p r(x)} + \overbrace{\p r(root)}^{\leqslant \p r(x)} - r(x) - \cancel{r(root)} \leqslant 1 + \left( \p r(x) - r(x) \right) \leqslant\\\leqslant 1+ 3\left( \p r(x) - r(x) \right)  $
        \item [zig-zag] 
\begin{figure}[!ht]
    \centering
    \incfig{zigzag-zigzig}
    \caption{zigzag-zigzig}
\end{figure}
\begin{align*}
    \tl T &= 2 + \p r(x) + \p r(p) + \p r(g) - r(x) \overbrace{-r(p)}^{\leqslant -r(x)} - \overbrace{r(g)}^{=\p r(x)}\\
          &\leqslant  2+\p r(p) + \p r(g) - \cancel{2r(x)} \ov{?}{\leqslant} 2\left( \p r(x) - \cancel{r(x)} \right)  \\
    \p r(p) + \p r(g) - 2\p r(x) \leqslant -2\\
    \log _2\left( \frac{\p s(p)\cdot \p s(g)}{\p s(x)\p s(x)} \right) &\leqslant -2 \\
    \underbrace{\frac{\p s(p)}{\p s(x)}}_A\cdot \underbrace{\frac{\p s(g)}{\p s(x)}}_B&\leqslant \frac{1}{4}\\    
.\end{align*}
$A+B\leqslant 1$ (размер $p$ и $g$ вместе меньше чем размер вершины над ними --  $x$)

$A\cdot B -- \max \iff A=B(=\frac{1}{2})\qquad A\cdot B = \frac{1}{4}$ 

$A =: \frac{\alpha}{\gamma}\quad B =:\frac{\beta}{\gamma}$ (обозначим соответствующие части итогового дерева как $\alpha, \beta$ и  $\gamma$)

 $A + B = \frac{\alpha + \beta}{\gamma}\quad \alpha + \beta < \gamma$
 

    \item [zigzig]

    \begin{align*}
        \tl T & = 2 + \cancel{\p r(x)} + \overbrace{\p r(p)}^{\leqslant \p r(x)} + \p r(g) - r(x) \overbrace{- r(p)}^{\geqslant -r(x)} - \cancel{r(g)}\\
              &\leqslant 2 + \p r(x) - 2r(x) + \p r(g) \leqslant 3\left( \p r(x) - r(x) \right)   \\
              r(x) + \p r(g) - 2\p r(x) \leqslant -2
    .\end{align*}

    Доказывается той же логикой
    \end{itemize}

    $\tl T(splay) \leqslant  1 + 3\left( \underbrace{\p r(x)}_{\leqslant \log n} - \underbrace{r(x)}_{\leqslant 0} \right) \leqslant 1 + \log n = O\left( \log  n \right)  $
\end{proof}

Итого не хуже логарифма, но может быть веселее, если случай не худший.

Обычно при оценке времени работы алгоритма, мы смотрим на худший случай. А теперь мы хотим посмотреть на время работы во всех случаях.

Как понять худший ли наш случай или нет, когда мы делаем $find(x_1)\ find(x_2)\ \ldots \ find(x_{k} )$?

Пусть делаем $find(x) \ldots find(x)\quad k$ раз

АВЛ-дерево потратит $k\log n$, а Splay-дерево -- $k + \log n$. Этот случай явно не худший и Splay-дерево это ``просекло''

Теперь смотрим на последовательность $find(x_1), \ldots, find(x_k)\quad T_{opt}$ -- минимальное время для обработки (сделаем специально дерево, которое хорошо крутится, подюирае коэффициенты, чтобы получилось минимальное время обработки)

Интересно отношение $\frac{T}{T_{opt}}$, т.е. на каком тесте оптимальное дерево действует быстро, а наше долго.

\begin{note}
    Есть гипотеза, что Splay-дерево динамически оптимально и отношение $\frac{T}{T_{opt}} \leqslant const???$ 

    Никто не знает правда это или нет. Есть несколько важных неравенств про разные случаи. На разное смотрели, везде получалось такое, какое надо.

    Если вдруг окажется, что это правда, то можно будет делать такие штуки:
    Есть задача и в ней нужно дерево поиска. Мы можем доказывать, что существует какое-то дерево, которое быстро работает. Тогда мы сможем пихнуть Splay-дерево и оно тоже будет быстро работать, потому что магия.

    Такие случаи в целом бывают. Есть реализации, про которые известно, что они лучше, чем любые другие реализации. Верно ли это про Splay-дерево -- неизвестно.
\end{note}


\end{document}

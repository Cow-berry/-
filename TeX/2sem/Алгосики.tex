\documentclass{book}
%nerd stuff here
\pdfminorversion=7
\pdfsuppresswarningpagegroup=1
% Languages support
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
% Some fancy symbols
\usepackage{textcomp}
\usepackage{stmaryrd}
% Math packages
\usepackage{amsmath, amssymb, amsthm, amsfonts, mathrsfs, dsfont, mathtools}
\usepackage{cancel}
% Bold math
\usepackage{bm}
% Resizing
%\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
% Optional font for not math-based subjects
%\usepackage{cmbright}

\author{Коченюк Анатолий}
\title{Конспект~по~алгоритмам~и~структурам~данных\\ II семестр}

\usepackage{url}
% Fancier tables and lists
\usepackage{booktabs}
\usepackage{enumitem}
% Don't indent paragraphs, leave some space between them
\usepackage{parskip}
% Hide page number when page is empty
\usepackage{emptypage}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{listings}
% Some shortcuts
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\R{\ensuremath{\mathbb{R}}}
\newcommand\Z{\ensuremath{\mathbb{Z}}}
\renewcommand\O{\ensuremath{\emptyset}}
\newcommand\Q{\ensuremath{\mathbb{Q}}}
\renewcommand\C{\ensuremath{\mathbb{C}}}
\newcommand{\p}[1]{#1^{\prime}}
\newcommand{\pp}[1]{#1^{\prime\prime}}
% Easily typeset systems of equations (French package) [like cases, but it aligns everything]
\usepackage{systeme}
\usepackage{lipsum}
% limits are put below (optional for int)
\let\svlim\lim\def\lim{\svlim\limits}
\let\svsum\sum\def\sum{\svsum\limits}
%\let\svlim\int\def\int{\svlim\limits}
% Command for short corrections
% Usage: 1+1=\correct{3}{2}
\definecolor{correct}{HTML}{009900}
\newcommand\correct[2]{\ensuremath{\:}{\color{red}{#1}}\ensuremath{\to }{\color{correct}{#2}}\ensuremath{\:}}
\newcommand\green[1]{{\color{correct}{#1}}}
% Hide parts
\newcommand\hide[1]{}
% si unitx
\usepackage{siunitx}
\sisetup{locale = FR}
% Environments
% For box around Definition, Theorem, \ldots
\usepackage{mdframed}
\mdfsetup{skipabove=1em,skipbelow=0em}
\theoremstyle{definition}
\newmdtheoremenv[nobreak=true]{definition}{Определение}
\newmdtheoremenv[nobreak=true]{theorem}{Теорема}
\newmdtheoremenv[nobreak=true]{lemma}{Лемма}
\newmdtheoremenv[nobreak=true]{problem}{Задача}
\newmdtheoremenv[nobreak=true]{property}{Свойство}
\newmdtheoremenv[nobreak=true]{statement}{Утверждение}
\newmdtheoremenv[nobreak=true]{corollary}{Следствие}
\newtheorem*{note}{Замечание}
\newtheorem*{example}{Пример}
\renewcommand\qedsymbol{$\blacksquare$}
% Fix some spacing
% http://tex.stackexchange.com/questions/22119/how-can-i-change-the-spacing-before-theorems-with-amsthm
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=\parskip \thm@postskip=0pt
}
\usepackage{xifthen}
\def\testdateparts#1{\dateparts#1\relax}
\def\dateparts#1 #2 #3 #4 #5\relax{
    \marginpar{\small\textsf{\mbox{#1 #2 #3 #5}}}
}

\def\@lecture{}%
\newcommand{\lecture}[3]{
    \ifthenelse{\isempty{#3}}{%
        \def\@lecture{Lecture #1}%
    }{%
        \def\@lecture{Lecture #1: #3}%
    }%
    \subsection*{\@lecture}
    \marginpar{\small\textsf{\mbox{#2}}}
}
% Todonotes and inline notes in fancy boxes
\usepackage{todonotes}
\usepackage{tcolorbox}

% Make boxes breakable
\tcbuselibrary{breakable}
\newenvironment{correction}{\begin{tcolorbox}[
    arc=0mm,
    colback=white,
    colframe=green!60!black,
    title=Correction,
    fonttitle=\sffamily,
    breakable
]}{\end{tcolorbox}}
% These are the fancy headers
\usepackage{fancyhdr}
\pagestyle{fancy}

% LE: left even
% RO: right odd
% CE, CO: center even, center odd
% My name for when I print my lecture notes to use for an open book exam.
% \fancyhead[LE,RO]{Gilles Castel}

\fancyhead[RO,LE]{\@lecture} % Right odd,  Left even
\fancyhead[RE,LO]{}          % Right even, Left odd

\fancyfoot[RO,LE]{\thepage}  % Right odd,something additional 1  Left even
\fancyfoot[RE,LO]{}          % Right even, Left odd
\fancyfoot[C]{\leftmark}     % Center

\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\usepackage{tikz}
\begin{document}
    \maketitle
    \chapter{Новые структуры данных}
    \section{Дерево отрезков}

    Segment Tree, Range Tree, Interval Tree -- можно наткнутся на другие структуры

    Есть массив $a$ на  $n$ элементов
     \begin{enumerate}
         \item set(i,v) $\quad a[i] = v$
         \item sum(l,r)  $\quad \sum_{i=l}^{r-1} a[i]$
    \end{enumerate}

    $\left[ 3,5,2,1,6,4,8,3 \right] $

    Построим дерево, где в каждом узле сумма двух под ним. Каждое число это сумма чисел на каком--то отрезке.

    Заменим 4 на 7. set(5, 7). Нужно пересчитать все узлы, которые выше него. Их логарифм.

    Теперь к сумме. Сумму от  $l $ до  $r$ мы будем раскладывать на суммы, которые мы уже знаем.
     \begin{enumerate}
        \item Как найти эти суммы: обойдём наше дерево рекурсивно, не заходя в плохие поддереве. Идём вниз: если в поддереве нет нужных элементов, выходим, если полностью содержится в нужном, берём эту сумму, иначе идём дальше вниз.
        \item Мы обошли не так много (порядка логарифма) узлов. Посмотрим на узлы, в которых не сработало отсечение. Тогда наш отрезок содержит одну из границ отрезка. Отрезков, которые содержат границу (правую или левую) не более $2\log n$. 

            Запуск рекурсии: узлов, в которых не сработало отсечение -- $2\log n$, всего узлов $\approx 4\log n$.
    \end{enumerate}

    Будем хранить полное двоичное дерево. У узла $i$ дети  $2i+1$ и  $2i+2$

    \begin{verbatim}
        set(i, v, x, lx, rx):
            if rx - lx = 1:
                tree[x] = v
            else:
                m = (lx+rx)/2
                if i < m:
                    set(i,v,2x+1,lx,m)
                else:
                    set(i,v,2x+2,m, rx)
                tree[x] = tree[2x+1] + tree[2x+2]

        sum(l, r, x, lx, rx):
            if l >= rx || lx >= r:
                return 0
            if lx >= l && rx <= r:
                return tree[x]
            m = (lx+rx)/2
            s1 = sum(l, r, 2x+1, lx, m)
            s2 = sum(l, r, 2x+2, m, rx)
            return s1 + s2
    \end{verbatim}

    Пусть мы теперь хотим посчитать минимум. Делаем то же самое, только в каждом узле храним не сумму на отрезке, а минимум. Только в случае пустого дерева вместо 0 в сумме надо вернуть $+\infty $ (нейтральный элемент по операции)

    Если нужно сделать операцию $a \bigotimes b$. Если у неё есть ассоциативность  $(a\otimes b)\otimes c = a\otimes (b\otimes c)$, то её можно встроить в дерево отрезков. 

$max, +, \cdot , \&, |, \text{НОД}, \text{НОК}$ 

\subsection{Снизу вверх}

Занумеруем также, но будем идти снизу вверх и без рекурсии.

\begin{verbatim}
    set(i, v): // n = 2^k
        x = i + n - 1
        delta = v - tree[x]
        while x >= 0:
            tree[x]+=delta
            x = (x+1)/2-1

    sum(l, r):
        l = n-1+r
        r = n-2+r
        res = 0
        while r >= l:
            if l % 2 = 0:
                res += tree[l]
            l = l / 2
            if r % 2 = 1:
                res += tree[r]
            r = r/2-1
        return res
\end{verbatim}

Если нужно посчитать другую функцию, поменяется нейтральный элемент. Если не коммутативная функцию, можно сначала считать левую, потом правую, а потом их сложить.

Такая реализация чуть лучше работает как $o(\log (l-r))$. Каждый раз разница между $ l$ и $r$ уменьшается в 2 раза.  

\section{Персистентное дерево отрезков}

$\begin{array}{c}
     15\\ 8 ~ ~ ~7\\ 3~5~6~1
 \end{array}
$

set(2,8) Сделаем новый узел рядом с 6. Рядом с узлом 7 на верхнем слое приделаем ещё один узел 9. А к корню приделаем узел 17. Так у нас появилось две параллельные версия дерева отрезков.
 

\section{Дерево отрезков v.2}

Теперь мы хотим:
\begin{enumerate}
    \item $add(l, r, v)\quad a[i]+=v\quad i = l \ldots r-1$
    \item $get(i)\quad return~a[i]$
\end{enumerate}

Построим дерево отрезков над массивом как в прошлый раз. В начале везде запишем нолики. Хотим добавить 3 к отрезку. Разобъём его на кусочки и в верхние узлы над нужным отрезком запишем тройки.

\begin{verbatim}
    add(l, r, v, x, lx, rx):
        if (lx >= r) || (l >= rx):
            return
        if lx >= l && rx <= r:
            tree[x] += v
            return
        m = (lx+rx)/2
        add(l, r, v, 2x+1, lx, m)
        add(l, r, v, 2x+2, m, rx)
\end{verbatim}

Сделаем $modify(l, r, v)\quad a[i] = a[i]\bigstar  v $, где $\bigstar $ ассоциативно и коммутативно.

Как жить с некоммутативными операциями? Записывать порядок. Точнее при получении значения пропихиваем верхние значения вниз справа.

\begin{verbatim}
    propogate(x):
        tree[2x+1]+=tree[x]
        tree[2x+2]+=tree[x]
        tree[x] = 0
\end{verbatim}

\begin{example}
    [Присваивание]
    set -- задаёт значение на отрезке. код такой же
    \begin{verbatim}
    propogate(x):
        if tree[x] != NO_OPERATION
    \end{verbatim}
\end{example}


Теперь сделаем две операции: прибавление и минимум, оба на отрезке.

Сначала сделаем дерево на минимум. Дальше при добавлении находим нужные отрезки и запоминаем, что нужно добавить 3 в узлах. минимумы снизу мы пересчитывать не будем

Когда доходим до узла добавляем v  в два массива: добавочный и минимумов + обвнояляем минимум, при спуске: $tm[x] = min(tm[2x+1], tm[2x+2]) + ta[x]$

\begin{verbatim}
    propogate

    min(l, r, x, lx, rx):
        ...
        ...
        ...
        s1 = min(l, r, 2x+1, lx, m)
        s2 = min(l, r, 2x+2, m, rx)
        return min(s1,s2) + ta[x]
\end{verbatim}

Здесь мы пользовались дистрибутивностью при пересчёте.
На самом деле, можно для недистрибутивных (например двух плюсов) сделать её такой, или помнить как именно нужно изменить

\section{Дерево Фенвика}

\begin{problem}
    Есть массив

    Нужно:
    \begin{enumerate}
        \item inc(i, v) $\quad a[i]=+v$
        \item sum(l,r)  $\quad \sum_{i=l}^{r-1} a[i]$
    \end{enumerate}

    Оба за логарифм
\end{problem}

Казалось бы всё это умеет дерево отрезков.. Но можно лучше! (всё ещё за логарифм, но) 

$f(i) = \sum_{j=p(i)}^{i} a[j]$ 

$sum(l, r) = sum(l) - sum(r)$

Как считается  $sum(i)$:
В последнем элементе лежит какая-то сумма. Добавим её к ответу. В  элементе до этой суммы (префикса) лежит какая-то сумма. Добавим её к ответу... Так, пока не дойдём до начала массива.

inc(i, v): ищем все суммы, содержащие $i$ и увеличиваем их на  $v$ 

По итогу нам нужна хорошая $p(x)$, чтобы и отрезков в  $sum(i)$ было поменьше (логарифм), и отрезков, содержащих  $i$ было тоже логариф.

$x:\quad \max k: (x+1) \vdots 2^k\quad p(x) = x+1-2^k$ (В терминах двоичной записи все единички идущие подряд в конце числа становятся нулями.

$p(x)$ довольно просто найти, это  $x\&(x+1)$

\begin{verbatim}
    sum(l,r):
        return sum(r) - sum(l)

    sum(r):
        x = r - 1
        res = 0
        while x >= 0:
            res += f[x]
            x = (x&(x+1))-1
        return res      
\end{verbatim}

Для инкремента нужно найти все такие $j\quad p(j)\leqslant i\leqslant j$

$j$ -- префикс, 0 и последовательность единиц.  $p(j)$ -- префикс, 0 и последовательность нулей.

Тогда  $i$, между ними, -- префикс, ноль и что-угодно. Соответственно такие $j$ из  $i$ можно получать заменяя последние  $n$ бит числа $i$ на единицы.

 \begin{verbatim}
    inc(i, v):
        j = i
        while (j < n):
            f[j] += v
            j = j | (j+1)

\end{verbatim}


\section{Разреженная таблица}

Хотим. Структуру. Данных.

Задан массив и он не меняется. Хотим посчитать минимум на любом отрезке за 1.

Можем предпосчитать за квадрат на всех отрезках и просто выдавать, но это долго.

$m[i,j] = \min\left( a\left[ i \ldots i+2^j-1 \right]  \right) \qquad i = 0 \ldots n-1\quad j = 0 \ldots \log n$

\begin{verbatim}
     for i = 0 .. n m[i,0] = a[i]
     for j = 1 .. log n
         for i = 0 .. n-2^j
            m[i,j] = min(m[i,j-1], m[i+2^(j-1), j-1])
\end{verbatim}

Теперь собственно как искать минимум:

$d = r-l\quad \max k: 2^k \leqslant  d$

$res = \min\left( m[l,k], m[r-2^k, k] \right) $ 

Нужно искать к-шки за О(1). Вообще с помощью \textit{битовых извращений} можно найти за $\log\log$, а с помощью \textit{страшных битовых извращений} вообще за  $O(1)$, но мы пока не будем выпендриваться  и просто предпосчитаем к-шки для всех  $d$

Ура! всё работает. Но вся эта схема сильно использует тот факт, что мы считаем минимум (использует свойство идемпотентности $min(x,x) = x$). Таких функций не прям чтоб много, а хотелось бы и с другими аналогичные вещи делать.

Давайте поделим отрезок пополам и посчитаем  префиксные cуммы справа и слева от середины. Тогда большой отрезок в запросе можно разбить на два:  до и после середины, сложить (применить функцию) и получить ответ.

Проблема: если отрезок в одной половине, то его в общем случае не посчитать. Решение: поделим половины отрезков так же, как делили целый. В итоге мы найдём $2n$ сумм.  $n$ на всё отрезке и по  $\frac{n}{2}$ на половинах. С каждым таким делением добавляется $n$. Всего делить можем  $\log n$ раз, значит сумм всего будет $n\log n$

Отвечаем на запрос: находим границу, которую отрезок от  $l$ до $r$ пересекает (первый бит числа  $l\& r$)

\section{Чё можно делать в двумерном случае}

\begin{problem}
    Есть прямоугольнички, они пересекаются. Ещё есть набор точек. Для каждой точки надо найти сколько прямоугольников покрывает эту точку
\end{problem}
\begin{proof}
    [Решение]

    Метод заметающей прямой. Поставим прямую и будем двигать её направо. Когда встретим точку, ответим на запрос про неё.

    Для одной линии считаем сколько покрывает каждую точку.

    Выделим все y кординаты, в которых есть вершина прямоугольника. 

    Встретили границу, делаем +=1 или -=1


\end{proof}

\begin{problem}
    Есть прямоугольники. Надо найти площадь их объединения

    Структура:
    \begin{enumerate}
        \item $a[i]\pm 1$ на отрезка
        \item $\sum len(i):a[i]>0$
    \end{enumerate}
\end{problem}


Дерево отрезков:
\begin{enumerate}
    \item sum(i,v)
    \item sum(l,r)
\end{enumerate}

Прямой аналог:
\begin{enumerate}
    \item set(i,j,v) \quad a[i,j] = v
    \item sum(l,r,t,b)
\end{enumerate}

Сделаем дерево отрзков для строчек. Каждая вершина отвечает за полосу из строчек. В каждой вершине хранится дерево отрезков по столбцам.

\section{Дерево Фенвика 2D}

$f(i) = \sum_{j=p(i)}^{i} a[j]$ 

$f(i,j) = \sum_{x=p(i)}^{i} \sum_{y=p(j)}^{j} a[x,y]$ 

План: сделать всё точно также

\begin{verbatim}
    x = i-1
    while x >= 0:
        rest += f(x)
        x = x&(x+1)-1

    x = i
    while x >= 0:
        y = j
        while y >= 0:
            rest += f(x,y)
            y = (y+1)&y-1
        x = (x+1)&x-1
\end{verbatim}

\section{Разреженные таблицы 2D}

$m[i,j] = min\left( a[i,i+a^j-1] \right) $ 

$m[i_1, j_1, i_2, j_2] = min\left( a[i_1, i_1+2^{j_1}-1, i_2, i_2+2^{j_2}-1 \right) $

precalc $O(n^2\lg^2)$

Запрос: $O(1)$

 \begin{problem}
     Есть двумерные точки. Хотим вывести все точки в прямоугольнике.

     Спроектируем точки на одну координату и построим на них дерево отрезков. В вершинах сортированные по другой координате точке. 
 \end{problem}

 \section{Бинпоиск.каскадирование}

 Делаем один и тот же бинпоиск на многих массивах. -- $O\left( n\log m \right) $ 

 Если знать в нашей последней задаче где бинпоиск в корне, можно легко понять как будет в рекурсии, элементы только пропадают и позиции однозначно соответствуют

 \textbf{Частичное каскадирование, Fractional Cascading}

 Чтобы не появлялось много лишних элементов, запихаем массива наверх. Чтобы не было слишком много, запихаем половину (каждый второй).

 При переходе смотрим на ближайшие запихнутые элементы. X между ними, проверем две позиции.

 А теперь у нас много элементов.

 \section{Дерево поиска}

set, map. Что умеет и то, и то? Хэш-таблица
 
add, remove, contains, put(k,v), get(k)

Хотим иметь линейный порядок.  $(x<y)$

Выполняется свойство: Все элементы в левом поддереве элементы меньше узла. Справа -- больше.

\begin{figure}[ht]
    \centering
    \incfig{tree}
    \caption{$contains(7)\quad add(4)$}
    \label{fig:tree}
\end{figure}



$h$ -- высота дерева. за  $O(h)$ можем получать и проверять на наличие

\begin{figure}[ht]
    \centering
    \incfig{removing}
    \caption{removing (дерево поиска)}
    \label{fig:removing}
\end{figure}

Поищем что-нибудь. Например lower bound -- $\min y \geqslant x\quad y\in Tree$

Стартуем в корне. Если элемент меньше $x$, идём вправо. Иначе запоминаем и идём влево поискать что-нибудь получше. 

Если дерево -- бамбук, то его высота  $n$. Оптимальное дерево -- бинарное, чтобы  $\log n$ было (меньше не сделать)

\section{АВЛ-дерево}

\begin{figure}[ht]
    \centering
    \incfig{rotation}
    \caption{rotation}
    \label{fig:rotation}
\end{figure}

$H_1, H_2$ -- высоты поддеревьев (правого и левого) $|H_1-H_2| \leqslant 1$

$H\leqslant c\cdot \lg n$

$n\geqslant 2^{\frac{H}{c}} = \underbrace{\left( 2^{\frac{1}{c}} \right)}_{\alpha}{}^H $

$n\geqslant \alpha^H$

$F(H) = \min$ число вершин в дереве высоты  $H$

$F(H) = 1 + F(H-1) + F(H-2) >2F(H-2)$

$F(H) \geqslant \frac{\sqrt{2}^H}{2} $ 

\begin{statement}
    Если добавить один элемент в дерево, высота любого дерева изменится максимум на 1

\end{statement}
    Было $(H, H+1)$ стало  $(H, H+2)$. Сломалось АВЛ-дерево

Сделаем операцию балансировки.

\begin{definition}
    [RR-поворот]

    Новый элемент добавился в правое поддерево правого поддерева. Крутим ребро $xy$


LL -- аналогично.
\end{definition}
\begin{figure}[ht]
    \centering
    \incfig{rr}
    \caption{RR}
    \label{fig:rr}
\end{figure}

\begin{definition}
    [RL]


LR также
\end{definition}
\begin{figure}[ht]
    \scriptsize
    \centering
    \incfig{rl}
    \caption{RL}
    \label{fig:rl}
\end{figure}
\lstset{language=Java}
    
 \begin{lstlisting}
     class Node{
        Node left, right;
        int key;
     }

     rotate(x, y, p) 
        if (y == x.right):
            x.right = y.left
            y.left = x
        else:
            x.left = y.right
            y.right = x
        x.recalc()
        y.recalc()

    recalc():
        H = max(left.H, right.H)+1

    Node add(Node x, Node nw)
        if (x == null)
            return nw
        if nw.key > x.key
            x.right = add(x.right, nw)
            x.recalc()
            y = x.right
            n = x.left.H
            if y.right == h+1:
                rotate(x,y)
                return y
            else if y.leftH = h+1:
                z = y.left
                rotate(y,z)
                rotate(x,z)
                return z
        else:
            x.left = add(x.left, nw)
            x.recalc()
            y = x.left
            h = x.right.H
            if y.left.H = h+1
                rotate(x,y)
                return y
            else if y.right.H == h+1
                z = y.right
                rotate(y,z)
                rotate(x,z)
                return z

 \end{lstlisting}
\begin{statement}
    А это всё тоже персистентным можно делать

    Можно всякие функции считать на отрезке ключей.
\end{statement}
 \end{document}

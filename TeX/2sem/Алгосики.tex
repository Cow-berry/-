\documentclass{book}
%nerd stuff here
\pdfminorversion=7
\pdfsuppresswarningpagegroup=1
% Languages support
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
% Some fancy symbols
\usepackage{textcomp}
\usepackage{stmaryrd}
% Math packages
\usepackage{amsmath, amssymb, amsthm, amsfonts, mathrsfs, dsfont, mathtools}
\usepackage{cancel}
% Bold math
\usepackage{bm}
% Resizing
%\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
% Optional font for not math-based subjects
%\usepackage{cmbright}

\author{Коченюк Анатолий}
\title{Конспект~по~алгоритмам~и~структурам~данных\\ II семестр}

\usepackage{url}
% Fancier tables and lists
\usepackage{booktabs}
\usepackage{enumitem}
% Don't indent paragraphs, leave some space between them
\usepackage{parskip}
% Hide page number when page is empty
\usepackage{emptypage}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{myStyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    extendedchars=\true
}

\lstset{style=myStyle}

\lstset{language=Python}
\usepackage{float}
% Some shortcuts
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\R{\ensuremath{\mathbb{R}}}
\newcommand\Z{\ensuremath{\mathbb{Z}}}
\renewcommand\O{\ensuremath{\emptyset}}
\newcommand\Q{\ensuremath{\mathbb{Q}}}
\renewcommand\C{\ensuremath{\mathbb{C}}}
\newcommand{\p}[1]{#1^{\prime}}
\newcommand{\pp}[1]{#1^{\prime\prime}}
% Easily typeset systems of equations (French package) [like cases, but it aligns everything]
\usepackage{systeme}
\usepackage{lipsum}
% limits are put below (optional for int)
\let\svlim\lim\def\lim{\svlim\limits}
\let\svsum\sum\def\sum{\svsum\limits}
%\let\svlim\int\def\int{\svlim\limits}
% Command for short corrections
% Usage: 1+1=\correct{3}{2}
\definecolor{correct}{HTML}{009900}
\newcommand\correct[2]{\ensuremath{\:}{\color{red}{#1}}\ensuremath{\to }{\color{correct}{#2}}\ensuremath{\:}}
\newcommand\green[1]{{\color{correct}{#1}}}
% Hide parts
\newcommand\hide[1]{}
% si unitx
\usepackage{siunitx}
\sisetup{locale = FR}
% Environments
% For box around Definition, Theorem, \ldots
\usepackage{mdframed}
\mdfsetup{skipabove=1em,skipbelow=0em}
\theoremstyle{definition}
\newmdtheoremenv[nobreak=true]{definition}{Определение}
\newmdtheoremenv[nobreak=true]{theorem}{Теорема}
\newmdtheoremenv[nobreak=true]{lemma}{Лемма}
\newmdtheoremenv[nobreak=true]{problem}{Задача}
\newmdtheoremenv[nobreak=true]{property}{Свойство}
\newmdtheoremenv[nobreak=true]{statement}{Утверждение}
\newmdtheoremenv[nobreak=true]{corollary}{Следствие}
\newmdtheoremenv[nobreak=true]{remember}{Воспоминание}
\newtheorem*{note}{Замечание}
\newtheorem*{example}{Пример}
\renewcommand\qedsymbol{$\blacksquare$}
\newcommand{\ov}[2]{\overset{#1}{#2}}
\newcommand{\tl}[1]{\widetilde{#1}}
% Fix some spacing
% http://tex.stackexchange.com/questions/22119/how-can-i-change-the-spacing-before-theorems-with-amsthm
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=\parskip \thm@postskip=0pt
}
\usepackage{xifthen}
\def\testdateparts#1{\dateparts#1\relax}
\def\dateparts#1 #2 #3 #4 #5\relax{
    \marginpar{\small\textsf{\mbox{#1 #2 #3 #5}}}
}

\def\@lecture{}%
\newcommand{\lecture}[3]{
    \ifthenelse{\isempty{#3}}{%
        \def\@lecture{Lecture #1}%
    }{%
        \def\@lecture{Lecture #1: #3}%
    }%
    \subsection*{\@lecture}
    \marginpar{\small\textsf{\mbox{#2}}}
}
% Todonotes and inline notes in fancy boxes
\usepackage{todonotes}
\usepackage{tcolorbox}

% Make boxes breakable
\tcbuselibrary{breakable}
\newenvironment{correction}{\begin{tcolorbox}[
    arc=0mm,
    colback=white,
    colframe=green!60!black,
    title=Correction,
    fonttitle=\sffamily,
    breakable
]}{\end{tcolorbox}}
% These are the fancy headers
\usepackage{fancyhdr}
\pagestyle{fancy}

% LE: left even
% RO: right odd
% CE, CO: center even, center odd
% My name for when I print my lecture notes to use for an open book exam.
% \fancyhead[LE,RO]{Gilles Castel}

\fancyhead[RO,LE]{\@lecture} % Right odd,  Left even
\fancyhead[RE,LO]{}          % Right even, Left odd

\fancyfoot[RO,LE]{\thepage}  % Right odd,something additional 1  Left even
\fancyfoot[RE,LO]{}          % Right even, Left odd
\fancyfoot[C]{\leftmark}     % Center

\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\usepackage{tikz}
\begin{document}
    \maketitle
    \chapter{Новые структуры данных}
    \section{Дерево отрезков}

    Segment Tree, Range Tree, Interval Tree -- можно наткнутся на другие структуры

    Есть массив $a$ на  $n$ элементов
     \begin{enumerate}
         \item set(i,v) $\quad a[i] = v$
         \item sum(l,r)  $\quad \sum_{i=l}^{r-1} a[i]$
    \end{enumerate}

    $\left[ 3,5,2,1,6,4,8,3 \right] $

    Построим дерево, где в каждом узле сумма двух под ним. Каждое число это сумма чисел на каком--то отрезке.

    Заменим 4 на 7. set(5, 7). Нужно пересчитать все узлы, которые выше него. Их логарифм.

    Теперь к сумме. Сумму от  $l $ до  $r$ мы будем раскладывать на суммы, которые мы уже знаем.
     \begin{enumerate}
        \item Как найти эти суммы: обойдём наше дерево рекурсивно, не заходя в плохие поддереве. Идём вниз: если в поддереве нет нужных элементов, выходим, если полностью содержится в нужном, берём эту сумму, иначе идём дальше вниз.
        \item Мы обошли не так много (порядка логарифма) узлов. Посмотрим на узлы, в которых не сработало отсечение. Тогда наш отрезок содержит одну из границ отрезка. Отрезков, которые содержат границу (правую или левую) не более $2\log n$. 

            Запуск рекурсии: узлов, в которых не сработало отсечение -- $2\log n$, всего узлов $\approx 4\log n$.
    \end{enumerate}

    Будем хранить полное двоичное дерево. У узла $i$ дети  $2i+1$ и  $2i+2$

    \begin{verbatim}
        set(i, v, x, lx, rx):
            if rx - lx = 1:
                tree[x] = v
            else:
                m = (lx+rx)/2
                if i < m:
                    set(i,v,2x+1,lx,m)
                else:
                    set(i,v,2x+2,m, rx)
                tree[x] = tree[2x+1] + tree[2x+2]

        sum(l, r, x, lx, rx):
            if l >= rx || lx >= r:
                return 0
            if lx >= l && rx <= r:
                return tree[x]
            m = (lx+rx)/2
            s1 = sum(l, r, 2x+1, lx, m)
            s2 = sum(l, r, 2x+2, m, rx)
            return s1 + s2
    \end{verbatim}

    Пусть мы теперь хотим посчитать минимум. Делаем то же самое, только в каждом узле храним не сумму на отрезке, а минимум. Только в случае пустого дерева вместо 0 в сумме надо вернуть $+\infty $ (нейтральный элемент по операции)

    Если нужно сделать операцию $a \bigotimes b$. Если у неё есть ассоциативность  $(a\otimes b)\otimes c = a\otimes (b\otimes c)$, то её можно встроить в дерево отрезков. 

$max, +, \cdot , \&, |, \text{НОД}, \text{НОК}$ 

\subsection{Снизу вверх}

Занумеруем также, но будем идти снизу вверх и без рекурсии.

\begin{verbatim}
    set(i, v): // n = 2^k
        x = i + n - 1
        delta = v - tree[x]
        while x >= 0:
            tree[x]+=delta
            x = (x+1)/2-1

    sum(l, r):
        l = n-1+r
        r = n-2+r
        res = 0
        while r >= l:
            if l % 2 = 0:
                res += tree[l]
            l = l / 2
            if r % 2 = 1:
                res += tree[r]
            r = r/2-1
        return res
\end{verbatim}

Если нужно посчитать другую функцию, поменяется нейтральный элемент. Если не коммутативная функцию, можно сначала считать левую, потом правую, а потом их сложить.

Такая реализация чуть лучше работает как $o(\log (l-r))$. Каждый раз разница между $ l$ и $r$ уменьшается в 2 раза.  

\section{Персистентное дерево отрезков}

$\begin{array}{c}
     15\\ 8 ~ ~ ~7\\ 3~5~6~1
 \end{array}
$

set(2,8) Сделаем новый узел рядом с 6. Рядом с узлом 7 на верхнем слое приделаем ещё один узел 9. А к корню приделаем узел 17. Так у нас появилось две параллельные версия дерева отрезков.
 

\section{Дерево отрезков v.2}

Теперь мы хотим:
\begin{enumerate}
    \item $add(l, r, v)\quad a[i]+=v\quad i = l \ldots r-1$
    \item $get(i)\quad return~a[i]$
\end{enumerate}

Построим дерево отрезков над массивом как в прошлый раз. В начале везде запишем нолики. Хотим добавить 3 к отрезку. Разобъём его на кусочки и в верхние узлы над нужным отрезком запишем тройки.

\begin{verbatim}
    add(l, r, v, x, lx, rx):
        if (lx >= r) || (l >= rx):
            return
        if lx >= l && rx <= r:
            tree[x] += v
            return
        m = (lx+rx)/2
        add(l, r, v, 2x+1, lx, m)
        add(l, r, v, 2x+2, m, rx)
\end{verbatim}

Сделаем $modify(l, r, v)\quad a[i] = a[i]\bigstar  v $, где $\bigstar $ ассоциативно и коммутативно.

Как жить с некоммутативными операциями? Записывать порядок. Точнее при получении значения пропихиваем верхние значения вниз справа.

\begin{verbatim}
    propogate(x):
        tree[2x+1]+=tree[x]
        tree[2x+2]+=tree[x]
        tree[x] = 0
\end{verbatim}

\begin{example}
    [Присваивание]
    set -- задаёт значение на отрезке. код такой же
    \begin{verbatim}
    propogate(x):
        if tree[x] != NO_OPERATION
    \end{verbatim}
\end{example}


Теперь сделаем две операции: прибавление и минимум, оба на отрезке.

Сначала сделаем дерево на минимум. Дальше при добавлении находим нужные отрезки и запоминаем, что нужно добавить 3 в узлах. минимумы снизу мы пересчитывать не будем

Когда доходим до узла добавляем v  в два массива: добавочный и минимумов + обвнояляем минимум, при спуске: $tm[x] = min(tm[2x+1], tm[2x+2]) + ta[x]$

\begin{verbatim}
    propogate

    min(l, r, x, lx, rx):
        ...
        ...
        ...
        s1 = min(l, r, 2x+1, lx, m)
        s2 = min(l, r, 2x+2, m, rx)
        return min(s1,s2) + ta[x]
\end{verbatim}

Здесь мы пользовались дистрибутивностью при пересчёте.
На самом деле, можно для недистрибутивных (например двух плюсов) сделать её такой, или помнить как именно нужно изменить

\section{Дерево Фенвика}

\begin{problem}
    Есть массив

    Нужно:
    \begin{enumerate}
        \item inc(i, v) $\quad a[i]=+v$
        \item sum(l,r)  $\quad \sum_{i=l}^{r-1} a[i]$
    \end{enumerate}

    Оба за логарифм
\end{problem}

Казалось бы всё это умеет дерево отрезков.. Но можно лучше! (всё ещё за логарифм, но) 

$f(i) = \sum_{j=p(i)}^{i} a[j]$ 

$sum(l, r) = sum(l) - sum(r)$

Как считается  $sum(i)$:
В последнем элементе лежит какая-то сумма. Добавим её к ответу. В  элементе до этой суммы (префикса) лежит какая-то сумма. Добавим её к ответу... Так, пока не дойдём до начала массива.

inc(i, v): ищем все суммы, содержащие $i$ и увеличиваем их на  $v$ 

По итогу нам нужна хорошая $p(x)$, чтобы и отрезков в  $sum(i)$ было поменьше (логарифм), и отрезков, содержащих  $i$ было тоже логариф.

$x:\quad \max k: (x+1) \vdots 2^k\quad p(x) = x+1-2^k$ (В терминах двоичной записи все единички идущие подряд в конце числа становятся нулями.

$p(x)$ довольно просто найти, это  $x\&(x+1)$

\begin{verbatim}
    sum(l,r):
        return sum(r) - sum(l)

    sum(r):
        x = r - 1
        res = 0
        while x >= 0:
            res += f[x]
            x = (x&(x+1))-1
        return res      
\end{verbatim}

Для инкремента нужно найти все такие $j\quad p(j)\leqslant i\leqslant j$

$j$ -- префикс, 0 и последовательность единиц.  $p(j)$ -- префикс, 0 и последовательность нулей.

Тогда  $i$, между ними, -- префикс, ноль и что-угодно. Соответственно такие $j$ из  $i$ можно получать заменяя последние  $n$ бит числа $i$ на единицы.

 \begin{verbatim}
    inc(i, v):
        j = i
        while (j < n):
            f[j] += v
            j = j | (j+1)

\end{verbatim}


\section{Разреженная таблица}

Хотим. Структуру. Данных.

Задан массив и он не меняется. Хотим посчитать минимум на любом отрезке за 1.

Можем предпосчитать за квадрат на всех отрезках и просто выдавать, но это долго.

$m[i,j] = \min\left( a\left[ i \ldots i+2^j-1 \right]  \right) \qquad i = 0 \ldots n-1\quad j = 0 \ldots \log n$

\begin{verbatim}
     for i = 0 .. n m[i,0] = a[i]
     for j = 1 .. log n
         for i = 0 .. n-2^j
            m[i,j] = min(m[i,j-1], m[i+2^(j-1), j-1])
\end{verbatim}

Теперь собственно как искать минимум:

$d = r-l\quad \max k: 2^k \leqslant  d$

$res = \min\left( m[l,k], m[r-2^k, k] \right) $ 

Нужно искать к-шки за О(1). Вообще с помощью \textit{битовых извращений} можно найти за $\log\log$, а с помощью \textit{страшных битовых извращений} вообще за  $O(1)$, но мы пока не будем выпендриваться  и просто предпосчитаем к-шки для всех  $d$

Ура! всё работает. Но вся эта схема сильно использует тот факт, что мы считаем минимум (использует свойство идемпотентности $min(x,x) = x$). Таких функций не прям чтоб много, а хотелось бы и с другими аналогичные вещи делать.

Давайте поделим отрезок пополам и посчитаем  префиксные cуммы справа и слева от середины. Тогда большой отрезок в запросе можно разбить на два:  до и после середины, сложить (применить функцию) и получить ответ.

Проблема: если отрезок в одной половине, то его в общем случае не посчитать. Решение: поделим половины отрезков так же, как делили целый. В итоге мы найдём $2n$ сумм.  $n$ на всё отрезке и по  $\frac{n}{2}$ на половинах. С каждым таким делением добавляется $n$. Всего делить можем  $\log n$ раз, значит сумм всего будет $n\log n$

Отвечаем на запрос: находим границу, которую отрезок от  $l$ до $r$ пересекает (первый бит числа  $l\& r$)

\section{Чё можно делать в двумерном случае}

\begin{problem}
    Есть прямоугольнички, они пересекаются. Ещё есть набор точек. Для каждой точки надо найти сколько прямоугольников покрывает эту точку
\end{problem}
\begin{proof}
    [Решение]

    Метод заметающей прямой. Поставим прямую и будем двигать её направо. Когда встретим точку, ответим на запрос про неё.

    Для одной линии считаем сколько покрывает каждую точку.

    Выделим все y кординаты, в которых есть вершина прямоугольника. 

    Встретили границу, делаем +=1 или -=1


\end{proof}

\begin{problem}
    Есть прямоугольники. Надо найти площадь их объединения

    Структура:
    \begin{enumerate}
        \item $a[i]\pm 1$ на отрезка
        \item $\sum len(i):a[i]>0$
    \end{enumerate}
\end{problem}


Дерево отрезков:
\begin{enumerate}
    \item sum(i,v)
    \item sum(l,r)
\end{enumerate}

Прямой аналог:
\begin{enumerate}
    \item set(i,j,v) \quad a[i,j] = v
    \item sum(l,r,t,b)
\end{enumerate}

Сделаем дерево отрзков для строчек. Каждая вершина отвечает за полосу из строчек. В каждой вершине хранится дерево отрезков по столбцам.

\section{Дерево Фенвика 2D}

$f(i) = \sum_{j=p(i)}^{i} a[j]$ 

$f(i,j) = \sum_{x=p(i)}^{i} \sum_{y=p(j)}^{j} a[x,y]$ 

План: сделать всё точно также

\begin{verbatim}
    x = i-1
    while x >= 0:
        rest += f(x)
        x = x&(x+1)-1

    x = i
    while x >= 0:
        y = j
        while y >= 0:
            rest += f(x,y)
            y = (y+1)&y-1
        x = (x+1)&x-1
\end{verbatim}

\section{Разреженные таблицы 2D}

$m[i,j] = min\left( a[i,i+a^j-1] \right) $ 

$m[i_1, j_1, i_2, j_2] = min\left( a[i_1, i_1+2^{j_1}-1, i_2, i_2+2^{j_2}-1 \right) $

precalc $O(n^2\lg^2)$

Запрос: $O(1)$

 \begin{problem}
     Есть двумерные точки. Хотим вывести все точки в прямоугольнике.

     Спроектируем точки на одну координату и построим на них дерево отрезков. В вершинах сортированные по другой координате точке. 
 \end{problem}

 \section{Бинпоиск.каскадирование}

 Делаем один и тот же бинпоиск на многих массивах. -- $O\left( n\log m \right) $ 

 Если знать в нашей последней задаче где бинпоиск в корне, можно легко понять как будет в рекурсии, элементы только пропадают и позиции однозначно соответствуют

 \textbf{Частичное каскадирование, Fractional Cascading}

 Чтобы не появлялось много лишних элементов, запихаем массива наверх. Чтобы не было слишком много, запихаем половину (каждый второй).

 При переходе смотрим на ближайшие запихнутые элементы. X между ними, проверем две позиции.

 А теперь у нас много элементов.

 \section{Дерево поиска}

set, map. Что умеет и то, и то? Хэш-таблица
 
add, remove, contains, put(k,v), get(k)

Хотим иметь линейный порядок.  $(x<y)$

Выполняется свойство: Все элементы в левом поддереве элементы меньше узла. Справа -- больше.

\begin{figure}[!ht]
    \centering
    \incfig{tree}
    \caption{$contains(7)\quad add(4)$}
    \label{fig:tree}
\end{figure}



$h$ -- высота дерева. за  $O(h)$ можем получать и проверять на наличие

\begin{figure}[!ht]
    \centering
    \incfig{removing}
    \caption{removing (дерево поиска)}
    \label{fig:removing}
\end{figure}

Поищем что-нибудь. Например lower bound -- $\min y \geqslant x\quad y\in Tree$

Стартуем в корне. Если элемент меньше $x$, идём вправо. Иначе запоминаем и идём влево поискать что-нибудь получше. 

Если дерево -- бамбук, то его высота  $n$. Оптимальное дерево -- бинарное, чтобы  $\log n$ было (меньше не сделать)

\section{АВЛ-дерево}

\begin{figure}[!ht]
    \centering
    \incfig{rotation}
    \caption{rotation}
    \label{fig:rotation}
\end{figure}

$H_1, H_2$ -- высоты поддеревьев (правого и левого) $|H_1-H_2| \leqslant 1$

$H\leqslant c\cdot \lg n$

$n\geqslant 2^{\frac{H}{c}} = \underbrace{\left( 2^{\frac{1}{c}} \right)}_{\alpha}{}^H $

$n\geqslant \alpha^H$

$F(H) = \min$ число вершин в дереве высоты  $H$

$F(H) = 1 + F(H-1) + F(H-2) >2F(H-2)$

$F(H) \geqslant \frac{\sqrt{2}^H}{2} $ 

\begin{statement}
    Если добавить один элемент в дерево, высота любого дерева изменится максимум на 1

\end{statement}
    Было $(H, H+1)$ стало  $(H, H+2)$. Сломалось АВЛ-дерево

Сделаем операцию балансировки.

\begin{definition}
    [RR-поворот]

    Новый элемент добавился в правое поддерево правого поддерева. Крутим ребро $xy$


LL -- аналогично.
\end{definition}
\begin{figure}[!ht]
    \centering
    \incfig{rr}
    \caption{RR}
    \label{fig:rr}
\end{figure}

\begin{definition}
    [RL]


LR также
\end{definition}
\begin{figure}[!ht]
    \scriptsize
    \centering
    \incfig{rl}
    \caption{RL}
    \label{fig:rl}
\end{figure}
\lstset{language=Java}
    
 \begin{lstlisting}
     class Node{
        Node left, right;
        int key;
     }

     rotate(x, y, p) 
        if (y == x.right):
            x.right = y.left
            y.left = x
        else:
            x.left = y.right
            y.right = x
        x.recalc()
        y.recalc()

    recalc():
        H = max(left.H, right.H)+1

    Node add(Node x, Node nw)
        if (x == null)
            return nw
        if nw.key > x.key
            x.right = add(x.right, nw)
            x.recalc()
            y = x.right
            n = x.left.H
            if y.right == h+1:
                rotate(x,y)
                return y
            else if y.leftH = h+1:
                z = y.left
                rotate(y,z)
                rotate(x,z)
                return z
        else:
            x.left = add(x.left, nw)
            x.recalc()
            y = x.left
            h = x.right.H
            if y.left.H = h+1
                rotate(x,y)
                return y
            else if y.right.H == h+1
                z = y.right
                rotate(y,z)
                rotate(x,z)
                return z

 \end{lstlisting}
\begin{statement}
    А это всё тоже персистентным можно делать

    Можно всякие функции считать на отрезке ключей.
\end{statement}

\section{Декартово Дерево}

\begin{enumerate}
    \item split(x). Из дерева делает два дерева, одно в котором все элементы $<x$, второе --  $\geqslant x$
    \item merge(T1, T2). Берёт два дерево, которые соответственно $<x$ и  $\geqslant x$ и склеивает их. 
\end{enumerate}

За $\log n$ научимся делать обе эти операции.

Итак, в каждом узле нашего дерева будет находится два ключа: $x, y$ и выполняется свойство: 
В правом поддереве:  $\left( <x; <y \right) $, в левом -- $\left( >x; < y \right) $

\begin{figure}[!ht]
    \centering
    \incfig{dektree}
    \caption{dektree}
    \label{fig:dektree}
\end{figure}

Если посмотреть на дерево $x$, получится нормальное дерево поиска. Если посмотреть на ключи  $y$, мы получим кучу.

В английском это всё называется Treap = Tree + Heap

$y = rand\left(  \right) \quad E(n) = O\left( \log n \right) $


\begin{figure}[!ht]
    \centering
    \incfig{treapbuilding}
    \caption{treapbuilding}
    \label{fig:treapbuilding}
\end{figure}

Как строить по набору точек на плоскости:
\begin{enumerate}
    \item Находим точку с наибольшим $y$, она, очевидно, корень. 
    \item Дальше всё, что правее неё, лежит в правом поддереве, всё, что левее -- в левом. Соответственно мы рекурскивно находим корни в этих поддеревьях и соединяем их с корнем на предыдущем шаге.
\end{enumerate}

Эта процедура очень похожа на quick sort, по той же причине эта штука делается за логарифм.

\begin{figure}[!ht]
    \centering
    \incfig{split}
    \caption{split}
    \label{fig:split}
\end{figure}

Split(node, x):
\begin{enumerate}
    \item смотрим с какой стороны стоит корень. Так мы можем сразу сделать вывод об одном из поддеревьев
    \item Запускаемся рекурсивно от второго поддерева
    \item Возвращаем пару деревьев (два корня)
\end{enumerate}

\begin{lstlisting}
    split(node, x):
        if node = null:
            return {null, null}
        if node.x < x:
            p = split(node.right, x)
            node.right = p.first
            return {node, p.second}
        else:
            p = split(node.left, x)
            node.left = p.second
            return {p.first, node}
\end{lstlisting}

\begin{figure}[!ht]
    \centering
    \incfig{merge}
    \caption{merge}
    \label{fig:merge}
\end{figure}

Merge(T1, T2):\quad Все узлы первого меньше всех узлов второго
\begin{enumerate}
    \item Определяем кто из двух корней будет итоговым корнем. 
    \item Делаем merge от второго дерева и ближайшего к нему поддерева главного.
    \item Возвращаем корень выбранный на первом шаге
\end{enumerate}

\begin{lstlisting}
    if A = null:
        return B
    if B = null:
        return A
    if A.y > B.y:
        A.right = merge(A.right, B)
        return A
    else:
        B.left = merge(A, B.left)
        return B
\end{lstlisting}

\begin{figure}[!ht]
    \centering
    \incfig{add}
    \caption{add}
    \label{fig:add}
\end{figure}

Add(A, x):
\begin{enumerate}
    \item Сплиттим на до $x$ и после $x$, получается три дерева: эти и с одним элементом -- $x$
    \item Два раза мёрждим, чтобы получить итоговое дерево
    \item Возвращаем результат последнего мёрджа
\end{enumerate}

\begin{lstlisting}
    add(A, node):
        if node.y > A.y:
            p = split(A, node.x)
            node.left = p.first
            node.right = p.second
        if node.x < A.x:
            A.left = add(A.left, node)
        else:
            A.right = add(A.right, node)
        return A

    remove(A, x):
        if A.x = x:
            return merge(A.left, A.right)
        if x < A.x:
            A.left = remove(A.left, x)
        else:
            A.right = remove(A.right, x)
        return A
\end{lstlisting}

На этом всём можно делать действия на отрезке как обычно, в том числе с propogate

Чтобы сделать персистентным, нужно найти все места, где мы присваиваем и не присваивать.
Пример:
\begin{lstlisting}
    Ap.right = merge
    Ap.left = A.left
    return Ap
\end{lstlisting}

такая копия, у которой одна половинка такая же, а другая изменённая

\begin{remember}
    Были списки [G F W O] + [P C Q] = [G F W O P C Q]

    Хотим два списка объектов обеъединять в один список. А также хотим делать сплит по позиции.

    split(3) -> [G F W], [O P C Q]
\end{remember}

План: хранить последовательности в дереве поиска 

\begin{figure}[!ht]
    \centering
    \incfig{exmerge}
    \caption{Пример merge'a}
    \label{fig:exmerge}
\end{figure}

$merge\left( W, Q \right)  \to merge\left( W, P \right) \to merge\left( O, P \right) \to merge\left( O, null \right) $

\begin{figure}[!ht]
    \centering
    \incfig{exsplit}
    \caption{Пример split'а}
    \label{fig:exsplit}
\end{figure}

$split\left( Q, 5 \right)  \to split\left( W, 5 \right)  \to  split\left( P, 2 \right) \to split\left( C, 0 \right) $


\section{Splay дерево}

Нет никаких вариантов, просто дерево. Любое дерево это валидное Splay дерево. Балансируем с помощью магии, о которой дальше

Есть операция $splay(x)$, которое последовательностью поворотов ставит $x$ в корень

\begin{figure}[!ht]
    \centering
    \incfig{splayop}
    \caption{операция Splay}
    \label{fig:splayop}
\end{figure}

Что делать со всеми остальными операциями? Ко всем операция, которые лезут вглубь дерева мы будем в конце приписывать Splay

Хотим доказать, что $\tl T(splay) = O\left( \lg n \right) $, из этого будет следовать, что и $\tl T(find) = \lg n$

\begin{figure}[!ht]
    \centering
    \incfig{zigop}
    \caption{Операция zig}
    \label{fig:zigop}
\end{figure}

\begin{figure}[!ht]
    \centering
    \incfig{zigzag-zigzig}
    \caption{zigzag-zigzig}
    \label{fig:zigzag-zigzig}
\end{figure}

Вот и весь алгоритм. Давайте ещё раз:
\begin{enumerate}
    \item Есть путь до $x$ и мы хотим сделать операцию  $splay$
    \item Смотрим на два уровня вверх от  $x$ и применяем  zig-zig или zig-zag соответственно
    \item Если остаётся только один родитель, делаем zig
\end{enumerate}

$T(find) = 2 T(splay)$

$\tl T(splay) = O\left( \log n \right)$

$\sum T(splay) \leqslant k \log n \implies \sum T(find) \leqslant 2k\log n \implies \tl T(find) = O(\log n)$

Слейтор, Тарьян. Доказывать амортищированные оценки будем с помощью метода потенциалов.

$\Phi$ -- потенциал  $\geqslant 0\qquad \tl T = T+\underbrace{\Delta\Phi}_{\geqslant 0} \geqslant \sum T$

Потенциал здесь -- мера того насколько дерево плохое. Хотим такой потенциал, чтобы  $\tl T = O\left( \log  n \right) $

$w(x)$ -- вес узла  $x$.  $w(x) = 1$ пока что все веса единицы

$s(x)$ -- суммарный вес поддерева  $x$

$r(x) = \log _2 s(x)$

$\Phi = \sum r(x)$

\begin{figure}[!ht]
    \centering
    \incfig{dokvo-splay}
    \caption{proof-splay}
    \label{fig:proof-splay}
\end{figure}

$\Phi \approx 8.6\qquad \Phi = \approx 15.3$

$\tl T(splay(x)) \leqslant 1+3\left( r'(x) - r(x) \right) $
 
Доказать это -- весь план

\begin{itemize}
    \item [zig] $\tl T \leqslant  1 + 3\left( \p r(x) - r(x) \right) $
    \item [zig-zag, zig-zig]  $\tl T \leqslant 3\left( \p r(x) - r(x) \right) $
\end{itemize}

Если сложить последовательность применений этих команд получится $3(r_2-r_1) + 3\left( r_3-r_2 \right)  + \ldots + 3\left( r_{n-1} - r_{n-2} \right) +1 + 3\left( r_n - r_{n-1} \right)  = 1 + 3\left( r_n-r_1 \right) $

\begin{note}
    Единицы в сумме может не оказаться hence знак $\leqslant $
\end{note}

\begin{proof}
    \begin{itemize}
        \item []
        \item [zig] $\tl T = \overbrace{T}^{=1} + \Delta \Phi = 1 + \cancel{\p r(x)} + \overbrace{\p r(root)}^{\leqslant \p r(x)} - r(x) - \cancel{r(root)} \leqslant 1 + \left( \p r(x) - r(x) \right) \leqslant\\\leqslant 1+ 3\left( \p r(x) - r(x) \right)  $
        \item [zig-zag] 
\begin{figure}[!ht]
    \centering
    \incfig{zigzag-zigzig}
    \caption{zigzag-zigzig}
\end{figure}
\begin{align*}
    \tl T &= 2 + \p r(x) + \p r(p) + \p r(g) - r(x) \overbrace{-r(p)}^{\leqslant -r(x)} - \overbrace{r(g)}^{=\p r(x)}\\
          &\leqslant  2+\p r(p) + \p r(g) - \cancel{2r(x)} \ov{?}{\leqslant} 2\left( \p r(x) - \cancel{r(x)} \right)  \\
    \p r(p) + \p r(g) - 2\p r(x) \leqslant -2\\
    \log _2\left( \frac{\p s(p)\cdot \p s(g)}{\p s(x)\p s(x)} \right) &\leqslant -2 \\
    \underbrace{\frac{\p s(p)}{\p s(x)}}_A\cdot \underbrace{\frac{\p s(g)}{\p s(x)}}_B&\leqslant \frac{1}{4}\\    
.\end{align*}
$A+B\leqslant 1$ (размер $p$ и $g$ вместе меньше чем размер вершины над ними --  $x$)

$A\cdot B -- \max \iff A=B(=\frac{1}{2})\qquad A\cdot B = \frac{1}{4}$ 

$A =: \frac{\alpha}{\gamma}\quad B =:\frac{\beta}{\gamma}$ (обозначим соответствующие части итогового дерева как $\alpha, \beta$ и  $\gamma$)

 $A + B = \frac{\alpha + \beta}{\gamma}\quad \alpha + \beta < \gamma$
 

    \item [zigzig]

    \begin{align*}
        \tl T & = 2 + \cancel{\p r(x)} + \overbrace{\p r(p)}^{\leqslant \p r(x)} + \p r(g) - r(x) \overbrace{- r(p)}^{\geqslant -r(x)} - \cancel{r(g)}\\
              &\leqslant 2 + \p r(x) - 2r(x) + \p r(g) \leqslant 3\left( \p r(x) - r(x) \right)   \\
              r(x) + \p r(g) - 2\p r(x) \leqslant -2
    .\end{align*}

    Доказывается той же логикой
    \end{itemize}

    $\tl T(splay) \leqslant  1 + 3\left( \underbrace{\p r(x)}_{\leqslant \log n} - \underbrace{r(x)}_{\leqslant 0} \right) \leqslant 1 + \log n = O\left( \log  n \right)  $
\end{proof}

Итого не хуже логарифма, но может быть веселее, если случай не худший.

Обычно при оценке времени работы алгоритма, мы смотрим на худший случай. А теперь мы хотим посмотреть на время работы во всех случаях.

Как понять худший ли наш случай или нет, когда мы делаем $find(x_1)\ find(x_2)\ \ldots \ find(x_{k} )$?

Пусть делаем $find(x) \ldots find(x)\quad k$ раз

АВЛ-дерево потратит $k\log n$, а Splay-дерево -- $k + \log n$. Этот случай явно не худший и Splay-дерево это ``просекло''

Теперь смотрим на последовательность $find(x_1), \ldots, find(x_k)\quad T_{opt}$ -- минимальное время для обработки (сделаем специально дерево, которое хорошо крутится, подбирает коэффициенты, чтобы получилось минимальное время обработки)

Интересно отношение $\frac{T}{T_{opt}}$, т.е. на каком тесте оптимальное дерево действует быстро, а наше долго.

\begin{note}
    Есть гипотеза, что Splay-дерево динамически оптимально и отношение $\frac{T}{T_{opt}} \leqslant const???$ 

    Никто не знает правда это или нет. Есть несколько важных неравенств про разные случаи. На разное смотрели, везде получалось такое, какое надо.

    Если вдруг окажется, что это правда, то можно будет делать такие штуки:
    Есть задача и в ней нужно дерево поиска. Мы можем доказывать, что существует какое-то дерево, которое быстро работает. Тогда мы сможем пихнуть Splay-дерево и оно тоже будет быстро работать, потому что магия.

    Такие случаи в целом бывают. Есть реализации, про которые известно, что они лучше, чем любые другие реализации. Верно ли это про Splay-дерево -- неизвестно.
\end{note}


\section{Scapegoat tree}

\begin{itemize}
    \item Построение: $n\log n$
    \item Зарос $\log ^2\quad \left( \log  n \right) $
    \item Изменение $\log ^2$
\end{itemize}

\begin{figure}[!ht]
    \centering
    \incfig{scapegoat}
    \caption{scapegoat}
    \label{fig:scapegoat}
\end{figure}


Проблема: если просто добавлять элементы в дерево поиска получится бамбук. Значит не хватает балансировки.

%\begin{figure}[!ht]
%    \centering
%    \incfig{goatbalance}
%    \caption{goatbalance}
%    \label{fig:goatbalance}
%\end{figure}

$\alpha = const\quad \frac{1}{2} \leqslant \alpha <1$. Скажем, что размер ребёнка должен быть не больше $\alpha w$

 $\alpha = 0.75$

\begin{figure}[!ht]
    \centering
    \incfig{goatex}
    \caption{goatex}
    \label{fig:goatex}
\end{figure}

Пусть добавили вершину. Найдём тех, кому стало больно. Возьмём поддерево того, кому плохо. Берём и полностью его строим с нуля. Если несколько берём максимальное.

Теперь смотрим за сколько всё это счастье работает.
\begin{statement}
    Амортизированное время работы не очень большое
\end{statement}
\begin{proof}
    Всё, кроме перестроения работает за логарифм (потому что высота)

\begin{figure}[!ht]
    \centering
    \incfig{rebuild}
    \caption{rebuild}
    \label{fig:rebuild}
\end{figure}
\begin{align*}
     \frac{\omega}{2} + x &> \alpha\left( \omega + x \right) \\
     \omega + 2x &> 2\alpha\left( \omega + x \right) \\
     2\left( 1-\alpha \right) x&>\left( 2\alpha-1 \right) \omega\\
     x &>\omega \underbrace{\frac{2\alpha-1}{2(1-\alpha)}}
.\end{align*}

$T = c_1\omega$

$\tl T = \frac{c_1\omega}{c_2\omega} = O(1)$

Но добавляя элемент, мы добавляем во все поддеревья, поэтому $\tl T(add) = O\left( \log n \right) $
\end{proof}

А теперь будем не АВЛ делать, а scapegoat.

Будет $T = c_1\omega \log \omega\quad \tl T(add) = O\left( \log ^2n \right) $

Будем в каждом узле хранить мапу сколько какой элемент встречается. Можно ещё выпуклую оболочку.
\section{ListOrderMaintenance}

\begin{figure}[!ht]
    \centering
    \incfig{lom}
    \caption{lom}
    \label{fig:lom}
\end{figure}

\begin{enumerate}
    \item $addAfter(x,y)$ -- добавить  $y$ после  $x$-а
    \item  $isBefore\left( x, y \right) $-- проверяет, что $x$ находится левее, чем  $y$
\end{enumerate}

При добавлении между $x$ и $z$ будем записывать $\frac{x+z}{2}$ 

В какой-то момент закончатся целые или точность дробных..

\begin{enumerate}
    \item Храним числа, когда добавляем делаем $\frac{x+z}{2}$. Работает, если немного элементов.

        Если $\approx k=\log M$ чисел (где М макс число), то всё норм. Но при этом обе операции работают за $O(1)$
    \item 
%\begin{figure}[!ht]
%    \centering
%    \incfig{goatplan}
%    \caption{goatplan}
%    \label{fig:goatplan}
%\end{figure} 

План: идём направо добавляем $11$ иначе  $00$ 

Теперь мы можем сравнивать за $O(1)$

Итог:
 \begin{itemize}
     \item $addAfter\quad O\left( \log n \right) $
     \item $isBefore\quad O(1)$
\end{itemize}
\end{enumerate}

Один логарифм убился, осталось убить ещё один логарифм.

Разобьём список на блоки не больше, чем по логарифму штук (но хотя бы $\frac{\log n}{2}$). И один элемент будет описанием этого блока

\begin{figure}[!ht]
    \centering
    \incfig{blocklog}
    \caption{blocklog}
    \label{fig:blocklog}
\end{figure}

Добавили в блок. Блок мог стать больше логарифма. Сделам два блока, каждый размером $\frac{\log n}{2}$ 

\begin{figure}[!ht]
    \centering
    \incfig{lomgoatadd}
    \caption{lomgoatadd}
    \label{fig:lomgoatadd}
\end{figure}

Амортизированно за $O(1)$

Итого штука, которая делает обе операции за единицу.




\section{LCA}

lowest common ancestor

\subsection{Двоичные подъёмы}

<todo> 20 минут лекции

$dist\left( u,v \right)  = \left( d(u) - d(w) \right)  + \left( d(v) - d(w) \right) $ 

$jump[v,k]$ -- вершина на расстоянии $2^k$ от $v$

 $v$ не больше  $n$ значений,  $k$ --  $\log n$

 Всего $n\log n$ значений, утверждается, что можно построить за $O(n\log n)$

 $jmp[v,0] = v.parent$
 \begin{lstlisting}
    for k = 1 .. lg n
        jmp[v,k] = jmp[jmp[v,k-1],k-1]
\end{lstlisting}    

Теперь, собственно, ищем $LCA(u,v)$
\begin{enumerate}
    \item Возьмём $u, v$
    \item (пусть $u$ нижу  $v$) Находим  $\p u$ на той же глубине, что и  $v$. Делается за  $\log $ прыжков
    \item Двоичный поиск с указателями:
        \begin{itemize}
            \item  Прыгаем на $2^k$, находим общего предка
            \item Прыгаем на поменьше.
            \item Если попали в разные, значит lca повыше, запускаемся от полученных вершин
            \item Если в одинаковые, значит либо это lca, либо есть пониже, уменьшаем степень
        \end{itemize}
\end{enumerate}

\begin{figure}[!ht]
    \centering
    \incfig{lcapic}
    \caption{lcapic}
    \label{fig:lcapic}
\end{figure}

\begin{lstlisting}
    if d(u) < d(v)
        swap(u,v)
    for k = lg n .. 0
        up = jmp[u,k]
        if d[up] >= d(v)
            u = up
    if u = v
        return u
    for k = lg n .. 0
        up = jmp[u,k]
        vp = jmp[v,k]
        if up != vp
            u = up
            v = vp
    return u.parent
\end{lstlisting}

В конце мы имеем две вершины, такие что как бы мы не прыгали наверх всегда встретимся в одно, значит если прыгнуть на 1, то получим lca.

Асимптотика логарифм $O(\log n)$

\begin{figure}[!ht]
    \centering
    \incfig{derevo-davno-ne-bylo}
    \caption{derevo-davno-ne-bylo}
    \label{fig:derevo-davno-ne-bylo}
\end{figure}

Дерево можно расписать в виде линии:

$a = $[1 2 4 2 5 6 5 2 1 3 7 5 1 8 1]

$b = $[0 1 2 1 2 3 2 1 0 1 2 1 0 1 0]

$b[i] = d[a[i]$ 

Пусть считаем $lca(3,6)$

Смотрим на кусок массива глубин между ними. Это какой-то путь между ними. Там точно есть lca, мимо него не пройти. Утверждвется, что lca -- вершина с минимальной глубиной. Если из lca выйти, то обратно мы не зайдём.

$\min b[i]$ на отрезке --  $lca$

\begin{problem}
    Есть много запросов на $lca$

\end{problem}

    \begin{tabular}{c|c|c}
        &предпосчёт & запрос\\\hline
        Двоичный подъём & $n\log n$ & $\log n$\\
        Э.О. + Д.О. & $n$ &  $\log n$\\
        Э.О. + Р.Т. & $n\log n$ & 1\\
        ФКБ & $n$ & 1\\
    \end{tabular}

План -- отвечать на вопросы про минимум за $1$ не потратив  $\log n$ на предпосчёт. Выберем кусочки длины $B = 3$. В каждом куске выберем минимум и его запомним

$\p b = $[0 1 0 1 0] -- длина  $\frac{n}{b}$ 

На $\p b$ построим Разреженую таблицу

Начнём с простого: как это нам поможет?

\begin{figure}[!ht]
    \centering
    \incfig{minfind}
    \caption{minfind}
    \label{fig:minfind}
\end{figure}

Эту таблицу мы строим за $\frac{n}{b}\log \frac{n}{b}$ 

Если взять $b = \log n$, то $\frac{n}{b}\log \frac{n}{b} = \frac{n}{\log n}\log \frac{n}{\log n} \leqslant \frac{n}{\log n}\log n = O(n)$

Объвим блоки [ 2 3 4 3 4 3] и [5 6 7 6 7 6] эквивалентными (можем добавить $3$)

Сколько есть классов эквивалентности? Будем вычитать первое число из блока.

$2^{B-1}$ блоков бывает, если длина блока  $B$

Класс эквивалентности можно кодировать так: Если следующее число на 1 больше, то 1, если меньше, то 0. Так составляется двоичное число для нумерации классов.

Переберём все классы эквивалентности. Для каждого класса эквивалентности посчитаем все возможные вопросы за  $O(2^B \cdot  B^2)$. Если $B = \log n$, то это $O(n\log ^2n$

Возьмём поменьше $B = \frac{\log n}{2}\quad O\left( 2^BB^2 \right)  = O(\sqrt{n}\log ^2n) = O(n) $

Остался обещанный запрос за $O(1)$. Для блоков, которые вошли целиком, лезем в таблицу и узнаём минимум на них. Для двух крайних тоже уже всё предпосчитано. 

 \begin{statement}
     С помощью такой прекрасной техники можно вообще в любом массиве искать минимум за единичку (здесь мы пользовались, что соседние элементы отличаются на 1)
\end{statement}

$a = $[5 4 8 6 2 5 3 7]

Построим Декартого дерево. Возьмём минимум и сделаем его корнем

\begin{figure}[!ht]
    \centering
    \incfig{anymin}
    \caption{anymin}
    \label{fig:anymin}
\end{figure}

\begin{statement}
    Минимум это $lca$ вершин. Если минимум дерева не на отрезке, то обе вершины лежат в одном поддереве. Если минимум на отрезке, то это корень и он разделяет вершины. Это единственная вершина, которая разделяет эти вершины.
\end{statement}

\section{Что ещё можно делать с деревьями}

\begin{note}
    Двоичные подъёмы работают, когда граф не меняется.
\end{note}

\begin{itemize}
   \item  calc(u,v) = sum на пути от u до v
   \item  set(u,v) = задать значение
\end{itemize}

Перед деревом подумаем про простой случай. Например наше дерево -- бамбук. Тогда нужно решать задачу на отрезке и решение этой задачи есть -- дерево отрезков.

\subsection{HLD}

План:
\begin{enumerate}
    \item возьмём дерево
    \item Выбираем для каждой вершины ребро к поддереву с наибольшим весом (самый тяжёлый)
    \item Выделяем пути таких рёбер
    \item Каждый путь тяжёлых рёбер -- дерево отрезков
    \item Смотрим на путь от $u$ до  $v$. Разбиваем его до двух отрезков до lca
\end{enumerate}

\begin{figure}[!ht]
    \centering
    \incfig{hlddef}
    \caption{hlddef}
    \label{fig:hlddef}
\end{figure}

\begin{figure}[!ht]
    \centering
    \incfig{hl-decomp}
    \caption{hl-decomp}
    \label{fig:hl-decomp}
\end{figure}

Предпосчёт -- $O(n)$

Кусков логарифм, в каждом дерево отрезков -- $O(\log ^2)$ на calc

Засунуть значение -- найти дерево отрезков и изменить его -- $O(\log n)$

\begin{figure}[!ht]
    \centering
    \incfig{smalltreewithnumbers}
    \caption{smalltreewithnumbers}
    \label{fig:smalltreewithnumbers}
\end{figure}

\begin{lstlisting}
    dfs(x):
        p.push_back(x)
        if heavy (x) == nul:
            return
        dfs(heavy(x))
        for y : children(x)
            if y != heavy(x)
                dfs(y)
\end{lstlisting}
Обход -- $\left[ \underline{1,3,5,7},\underline{6},\underline{2,4} \right] $

Второе упрощение в жизни -- lca не нужно сразу считать, можно по ходу. Для каждой вершины можно храниты ссылочку в верхнюю вершину её тяжёлого пути. Глубины тоже посчитать можно, если нужны.

\begin{enumerate}
    \item Смотрим на две вершины и их тяжёлые пути
    \item Если они совпадают, то считаем между ними расстояние.
\end{enumerate}

\begin{lstlisting}
    x = top(u)
    y = top(v)
    if x = y:
        res += sum(u,v)
        return red
    # y пониже. y ниже, чем lca, кусок с y можно добавить
    if d[y] >= d[x]:
        res += sum(v,y)
        v = y.parent # (если на рёбрах, то это либо надо учеть, либо сама добьётся, включившись)
    else:
        rest += sum(u,x)
        u = x.parent
\end{lstlisting}

\section{Бонус: }
\begin{figure}[!ht]
    \centering
    \incfig{bonus-derevo}
    \caption{bonus-derevo}
    \label{fig:bonus-derevo}
\end{figure}
\begin{problem}
    Есть у нас дерево

Нужно находить $la(v,l)$ -- предок  $v$ на уровне $l$

$D = \left( d[v] - l \right) $
\end{problem}

\begin{enumerate}
    \item Выберем длинные пути
    \item Из этих путей делаем лесенки: возьмём длинный путь, в нём $k$ вершин. Найдём следующие  $k$ вершин сверху (или до корня). Всё это вместе назовём лесенкой. Каждая лесенка -- массив
    \item  $\sum$ длина лесенок $=n$.  $\sum$ длина лесенок  $\leqslant 2n$. Лесенка строится за линию от размера лесенки. Сумма размеров путей -- $n$, сумма времени на лесенки --  $O(n)$
\end{enumerate}

Считаем $la(v,l)$:
 \begin{enumerate}
    \item $v$ лежит на длинном пути. Берём лесенку этого пути и поднимаемся по ней. 
    \item Возьмём новый длинный путь и новую лесенку. Если мы перешагнули нужный уровеь, значит где-то на пути находится 
    \item Каждый раз мы увеличиваем длину длинного пути как минимум в два раза (потому что у вершине, в которую мы перешли, есть уже путь длинной $2 \cdot  $ предыдущюю длину. Значит длинный путь у новой вершины как минимум такой длины, по выбору длинного пути)
    \item Значит таких прыжков не больше, чем логарифм штук.
\end{enumerate}

\begin{lstlisting}
    x = top(v)
    if d(x) > l:
        v = x
    else:
        return ladde[v][l-d[x]]
\end{lstlisting}    

\begin{note}
    у нас есть два подхода: двоичные подъёмы и лесенки. Давайте их скрестим
\end{note}

\begin{figure}[!ht]
    \centering
    \incfig{ezh-x-ezh}
    \caption{ezh-x-ezh}
    \label{fig:ezh-x-ezh}
\end{figure}

Будем делать двоичные подъёмы только в листьях.

Возьмём лист в поддереве $v$. Оттуда делаем двоичный подъём, а оттуда по лесенке . Это делается за константу.

Случай: ёжик, одна вершина с  $n$ детьми

\begin{figure}[!ht]
    \centering
    \incfig{ezh-real}
    \caption{ezh-real}
    \label{fig:ezh-real}
\end{figure}

Отрежем все деревья тяжелее, чем $B (=3)$

Если  $B \sim \log n$, то появится время на двоичные подъёмы. Листов станет $\leqslant \frac{n}{B}$
 
Случаи:
\begin{enumerate}
    \item $v$ не в листе. Делаем как раньше, в лист, двоичный подъём, лесенка
    \item  $v$ в отрезанном листе. У неё есть ссылка на верхнюю вершину листа. Берём вершинку выше (родителя), а дальше алгоритм из пункта 1)
    \item  $v$ внутри и предок тоже внутри. Число типов $\leqslant 2^{2B}\leqslant \sqrt{n} . \sphericalangle B = \frac{\log n}{4}$ 

        Смотрим на одно дерево конкретного типа, считаем на нём все возможные запросы (табличка mem[type,v,l]) -- $O(\sqrt{n}\log ^2n) = O(n) $
\end{enumerate}

\section{TODO}
\section{Euler TODO}
\section{Цетроидная декомпозиция}

Назовём близкими вершины, для которых $dist(u,v)\leqslant D$

Найти число таких пар можно бинпоиском, префиксными суммами, двумя указателями ... но это на бамбуке

Выберем вершины, поделим пути на те, которые содержат и которых не содержат вершину

\begin{figure}[!ht]
    \centering
    \incfig{deli}
    \caption{deli}
    \label{fig:deli}
\end{figure}

Когда у нас несколько деревьев, одно выбираем, а все другие запихиваем в большое дерево поиска и ищем там

$d[v] = dist(v, c)$

\begin{lstlisting}
    BST
    for t in trees:
        for v in t:
            find(bst, D - d(u))
        for v in t:
        insert(bst, v)
\end{lstlisting}

Для хорошести рекурсии нужно, чтобы самый большой кусок при раздлении был поменьше

\begin{lemma}
    В каждом дереве есть вершина, такая что при разделении по ней куски получаются $\leqslant n$
\end{lemma}
\begin{proof}
    Подвесим за любую вершину. Посчитаем все веса поддеревьев.

    Если какое-то дерево слишком большое, то пойдём в ребёнка большего половины.

    При переходе мы знаем что всё вне ребёнка $\leqslant  \frac{n}{2}$, значит нужно проверить , что у детей детей $\leqslant \frac{n}{2}$, если нет, то идём дальше. За один обход находим нужную вершины, называемыю \underline{центроидом}
\end{proof}

Алгоритм:
\begin{enumerate}
    \item Делим по центроиду
    \item В кусках рекурсивно высчитываем пути
    \item В путях меньше деревьями считаем процедурой выше.
\end{enumerate}

\begin{problem}
    Есть сеть дорог. 

    [картинка] меня можно пнуть её сделать

    Картинка делеает за $n\log n$
\end{problem}
\begin{proof}
    Найдём первую оющую компоненту двух вершин

    Предпосчитаем расстояния от всех центродов к их детям

    \begin{lstlisting}
        for c in centroids[v]:
            i = binsearch(component[c], d - dist(c, v))
            res = min(res, prefmin[c][i])
    \end{lstlisting}
\end{proof}

\begin{figure}[!ht]
    \centering
    \incfig{kartinka}
    \caption{kartinka}
    \label{fig:kartinka}
\end{figure}

Если считать что-то менее хорошее, чем минимум, например сумму, то можно посчитать два раза если зайти в то же поддерево из которого мы вышли.

Задача: нам нужно посчитать сумму по всех компонентам, кроме нашей

Человеческий код:
\begin{lstlisting}
    build(v):
        # строит декомпозицию
        c = find_centroid(v)
        mark[c] = True # Чтобы по ней больше не ходить
        prepare(c) # посчитать расстояни, посортировать, ... all the fun stuff
        for u in g[c]: # рёбра-соседи
            if (not mark[u]):
            build(u)

    prepare(v):
        dfs(v, -1)
    
    dfs(v, p, d):
        for u in g[u]:
            if !mark[u] and u != p:
                dfs(u,v,d+1)
        centroids[v].add({c, d})

    for v = 1 ... n:
        for (c, d) in centroids[v]:
            comp[c].add({d, r})
            comp2[c].add({dp, v}) # в comp2 вершину сортируются по расстоянию до предудущго центроида
            dp = d # dp -- расстояние до предыдущего центроида

    for c = 1 ... n:
        sort(comp(c))
        sort(comp2(c))


    calc(v, D):
        for (c, d) in centroid[v]:
        i = binsearch(comp[c], D - d)
        res += prefsum[c][i]
        i = binsearch(comp2[c], D - dp)
        res -= prefsum2[c][i]
        dp = d

    calc(v, D):
    k = centroids[v].size
    for i = 0 .. k-1:
        c = centroids[v][i]
        x = binsearch(comp[c], D - d)
        res += prefsum[c][x]
        if i < k-1:
            cp = centroids[v][i+1]
            x = binsearch(comp2[cp], D - d)
            res  = prefsum2[c'][x]
\end{lstlisting}

Итоговая асимптотика: $O\left( n\log ^2 n \right) $ на предпосчёт. $O\left( \log ^2 \right)$ на запрос


\section{Алгоритмы во внешней памяти}

RAM-модуль: доступ за $O(1)$

\begin{figure}[!ht]
    \centering
    \incfig{sistema}
    \caption{sistema}
    \label{fig:sistema}
\end{figure}


$M, B$ -- параметры системы. Время работы = число чтений/записей блоков размера  $B$

Эта модель может применяться к много чему, например к облачному хранилищу с долгим временем запроса и большими блоками запроса соответственно.

Тупое решение: пусть у нас есть массив и нам нужно посчитать на нём сумму. Разделим его на блоки размера $B$.  $T(Scan(N)) = \left\lceil \frac{N}{B} \right\rceil \approx \frac{N}{B} + 1 $ 

Отсортируем массив: хотим работать с блоками, MergeSort


\begin{figure}[!ht]
    \centering
    \incfig{morzh}
    \caption{morzh}
    \label{fig:morzh}
\end{figure}

$\frac{N}{B} \log \frac{N}{B}$ 

так мы используем только 3 Мб памяти. Давайте сливать сразу много блоково


\begin{figure}[!ht]
    \centering
    \incfig{big-morzh}
    \caption{big-morzh}
    \label{fig:big-morzh}
\end{figure}

$k \approx \frac{M}{B} \quad M \geqslant kB$ 

$Sort(N) = \frac{N}{B} \log _{\frac{M}{B}} \frac{N}{B}$ 


\begin{statement}
    Это время оптимально.
\end{statement}
\begin{proof}
    N! всех перестановок. Выбираем одну, нужно $\log \left( N! \right) $ сравнений (примерно $N\log N$)

    Когда мы мёрджим блоки размера  $M$ и $B$. 

    $\log  C_m^B \approx \log \frac{M(M-1)(M-2)\ldots (M-B+1)}{B (B-1)(B-2) \ldots 1} \approx B \log \frac{M}{B}$
\end{proof}



Стэк во внешней памяти: 

\begin{figure}[!ht]
    \centering
    \incfig{stack}
    \caption{stack}
    \label{fig:stack}
\end{figure}

$O(1)$ -- нехорошо

$O(\frac{1}{B})$ -- правильная оценка. 1 запрос на $B$ операций

Дерево поиска:


B-дерево. В каждом узле хранится  $B$ ключей и  $B+1$ ребёнка. Время работы $O\left( \log _b^N \right) $ 

C деревом посика нельзя запросы меньше 1, потому что дерево поиска может выдать любой свой элемент, а держать их все в оперативной памяти оно не может, значит всегда есть запрос, который заставит его что-то подгрузить.

Хотим обратную перестановку. Если бы не было внешней памяти, то
\begin{lstlisting}
    for i = 1 .. n:
        r[p(i)] = i
\end{lstlisting}


С памятью запишем все такие пары $(i, p[i])$ и отсортируем их по второму элементу

$35214\quad (1,3), (2,5)(3,2)(4,1)(5,4) \implies (4,1)(3,2)(1,3)(5,4)(2,5)$ -- выбираем первые элементы пар и это будет обратная перестановка.

Есть два массива. Хотим посчитать третий, чтобы $c[i] = b[a[i]\quad a[i]\in [1 .. N]$

Сделаем массив пар  $(i, a[i])$ И  $(i, b[i])$ 

Отсортируем первый по $a[i]$, а второй по  $i$. Тогда переход между ними будет приятный (можно идти указателями по сортированным массивам)


 \begin{problem}
     Есть массив $next$, в котором написан какой элемент следующий после данного.  $[5, 7, -, 3, 2, 4]\quad 1 \to 5\to 3\to 6\to 2\to 7\to 4$

\end{problem}   
\begin{proof}
     Безыдейно:
     \begin{lstlisting}
         x = 1
         for i = 1 .. n:
            print x
            x = next(x)
     \end{lstlisting}

     Переделаем задачу: Есть элементики
     
     
\begin{figure}[!ht]
    \centering
    \incfig{elementiki}
    \caption{elementiki}
    \label{fig:elementiki}
\end{figure}

Если делать все двоичные подъёмы, то будет $O\left( \log N \cdot  \frac{N}{B}\log _{\frac{M}{B}}\frac{N}{B} \right) $ 

Можно делать не все подъёмы.


\begin{figure}[!ht]
    \centering
    \incfig{ne-vse-podъёmы}
    \caption{ne-vse-podъёmы}
    \label{fig:ne-vse-podъёmы}
\end{figure}


Поставим в элементы рандомные битики. В местах, где с 1 переходим на 0 будем делать переход через 2 (удалять тот, на котором 1)

\begin{lstlisting}
    if renoved[Next[i]:
        Next[i] = Next[Next[i]
        W[i] = N[i] + W[Next[i]]
\end{lstlisting}

\end{proof}

\section{Классы сложности}

$O(n^2)\quad O\left( n^3\cdot \log n \right) \ldots$

Класс $P$, решается за Полином  $O(n^k)$

Хорошие задачи, они решаются

Сам полином зависит от того где решаем. (1 и $\log n$ в зависимости от RAM-модели или Pointer Machine) 

Но это если за полином на одной машине, то за полином и на другой

Есть тупая машина под название Машина Тьюринга

\begin{note}
    У машины Тюринга есть большаая лента, на которой хранятся данные

    Есть одно место, текущая ячейка, на которой хранятся данные

    Нет переменных, есть только состояние

\begin{figure}[!ht]
    \centering
    \incfig{turing-auto}
    \caption{turing-auto}
    \label{fig:turing-auto}
\end{figure}

$(state, x) \to (\p x, staet \p e, \leftarrow \rightarrow \downarrow$
\end{note}

Локальных переменных нет, их нужно где-то хранить на ленте

\begin{lstlisting}
    for i = 0 .. n-1
\end{lstlisting}

\begin{figure}[!ht]
    \centering
    \incfig{for-turing}
    \caption{for-turing}
    \label{fig:for-turing}
\end{figure}


\begin{figure}[!ht]
    \centering
    \incfig{classes-pnp}
    \caption{classes-PNP}
    \label{fig:classes-pnp}
\end{figure}

Есть задачи, которые не решаются за полином

\begin{example}
    Есть шахматная доска $n\cdot x$, на которой стоят фигуры. Вопрос: выиграют ли белые?

    задача решается, но за экспоненциальное время

    $O\left(e^{n^k}  \right) $
\end{example}

$P\quad O\left( n^k \right) $

$EXP\quad O\left(e^n  \right) $

$R O\left( \text{что-нибудь} \right) $

$Halt\left( p, x \right) \quad p$ -- программа (М.Т.) $x$ -- ввод

Правда ли, что программа  $p$ остановится на вводе  $x$ (не будет работать бесконечно)

 \begin{proof}
    \begin{lstlisting}
        bool f(p):
            if HALT(p, p):
                while True:
                    pass
            else:
                return True
    \end{lstlisting}

    $f(f)$

     \begin{enumerate}
         \item $f(f)$ Остановится, первая ветка  $f(f)$ зациклиться
         \item  $f(f)$ зациклиться, значит вторая ветка, значит остановится
    \end{enumerate}

    Резюме: анализировать чужие программы сложно
\end{proof}

Если изучаем что-то не сильно проще, чем Машина Тьюринга, скорее всего она неразрешима

\begin{example}
    Игра ``жизнь''

    бесконечное (уже повод задуматься) поле. Есть клеточки, живые и мёртвые.

    Есть начальное состояние

    Анализировать сложно, примерно потому что можно съэмулировать машину тьюринга

    Если бы могли, то решилась бы и машина Тююринга (был бы ответ "что будет в конце")
\end{example}

\begin{example}
    Клеточный автомат с состоянием на прямой. Каждая клеточка знает предыдущую и следующую.

    Функции от 3 перемнных, их 256, не так много, можно перебрать

    $x \underline 0 1\to  1$

    $1 \underline 1 1 \to  0$

    Вёл себя странно, через некоторое время останавливался, похоже на машину Тюринга

    Пацаны потом доказали, что действитель Тьюринг-Полная
\end{example}

\begin{example}
    Есть квадратики, на сторонах написаны числа, есть несколько типов квадратиков

\begin{figure}[!ht]
    \centering
    \incfig{kvadratiki}
    \caption{kvadratiki}
    \label{fig:kvadratiki}
\end{figure}

Соединяется по равным рёбрам.

Проверить, заполняет ли оно плоскость. Неразрешима
\end{example}

\begin{note}
    Если бы подобные задачи решались, было бы скучно, большая Теорема Ферма доказывалась бы HALT'ом по программе, которая ищет контрпример к ней
\end{note}

Посмотрим на границу между $P$ и  $EXP$. Ребята выделили ещё один класс --  $NP$

$NP$ -- решается за $O\left(n^k  \right) $ на недетрминированной машине

$\omega$ -сертификат

Ответ ``да'' $\iff \exists \omega: f(x, \omega) = 1$

Например есть граф и нужно проверить есть ли в нём Гамильтонов Цикла. Она из $NP$
 \begin{proof}
    $\omega$ -- набор подсказок -- куда идти

    Задача из  $NP$, когда её ответ можно проверить. По набору подсказок куда идти понять правильно ли это.
\end{proof}

$Co_NP$ -- легко проверить, что ответа нет, крайне сложно проверить, что ответ есть.

Не знаем можем ли реать задачи из  $CoNP$ за полином и оказывается, что там довольно много задач


Хочется сравнивать сложности задач  $A$ не проще  $B$. Если  $A$ научимся, то и  $B$ тоже

Хотим  $B$ свести к  $A$

$B(x) = A(f\left(x \right) )$

\begin{example}
\begin{figure}[!ht]
    \centering
    \incfig{mal-graph}
    \caption{mal-graph}
    \label{fig:mal-graph}
\end{figure}

Можем свести Гамльтонов цикл к Гамильтонову пути.

В $NP$ есть задачи, к которым сводятся все задачи  $NP$, они называются  $NP$-трудными.

 $NP$-полная  $\iff NP$-трудная и $\in NP$

 Таких задач тоже довольно много.. Если научиться решать их за полином, то решатся все за полином

 Периодически смотрят на задачю внутри  $NP$ и  $P$. Тыкают в неё долго и выясняют, что она либо  $P$, либо  $NP$-полная
 
 Если  $P = NP$, всё немного странно в мире.
\end{example}

$(p, x, n^k)$, права ли, что  $p$ остановится на вводе  $x$ за не более, чем  $n^k$ действий. Если решить такую, решим всё из  $NP$

Эту НМС (недерминированную машину тюринга) можно эмулировать разными штукми

 \begin{example}
    $n$ переменных  $x_1,x_2, \ldots, x_n$

    $1 = (x_1 \lor \overline x_2 \lor \overline x_3) \land \left( x_2 \lor \overline x_5 \lor x_8 \right) \land \ldots$ 
    
    $NP$, можно сказать значения всех переменных

     3-SAT
\end{example}

\begin{example}
    Сведём Гамильтонов граф и 3-SAT

\begin{figure}[!ht]
    \centering
    \incfig{gamil}
    \caption{gamil}
    \label{fig:gamil}
\end{figure}
\end{example}


\begin{example}
    Рюкзак. Есть $w_i$. Хотим набрать  $\sum w_i = S$. Задача на да/нет. Она  $NP$-полная

    есть сертификат, проверит просто.

    $(x_1 \lor \overline x_2 \lor x_3) \land \left( \overline x_1 \lor x_3\lor \overline x_4 \right) \land \left( x_1 \lor x_2 \lor \overline x_3 \right)  \ldots$

    $x_1\quad 1 0 1 \ldots$

    $\overline x_1\quad  0 1 0$
    
     $x_2\quad 0 0 1$

     $\overline x_2\quad 1 0 0$

     $x_3\quad 1 1 0$

     $\overline x_3 0 0 1$

     Выберем $x_1\quad \overline x_2\quad x_3$ -- 311 (поразрядно складываем)

     Запретим брать одновременно $x_i$ и  $\overline x_i$. Сделаем ещё один бит спецаильно для этого. У первой переменной будет  $1 0 0 \ldots$, у второй $0 1 0 \ldots$

     Скажем, что сумма этих дополнительных разрядов должны быть с 1 максимум везде

     Теперь у нас есть $311$,  а хочется, чтобы разряды были одинаковые. Добьём всё до 7. К каждому рахряду ещё предметы  $00600.., 00500.., 00400..$

     $S = 777\ldots 77111\ldots 11$

\end{example}
\end{document} 

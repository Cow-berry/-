\documentclass{book}
%nerd stuff here
\pdfminorversion=7
\pdfsuppresswarningpagegroup=1
% Languages support
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
% Some fancy symbols
\usepackage{textcomp}
\usepackage{stmaryrd}
% Math packages
\usepackage{amsmath, amssymb, amsthm, amsfonts, mathrsfs, dsfont, mathtools}
\usepackage{cancel}
% Bold math
\usepackage{bm}
% Resizing
%\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
% Optional font for not math-based subjects
%\usepackage{cmbright}

\author{Коченюк Анатолий}
\title{Оси}

\usepackage{url}
% Fancier tables and lists
\usepackage{booktabs}
\usepackage{enumitem}
% Don't indent paragraphs, leave some space between them
\usepackage{parskip}
% Hide page number when page is empty
\usepackage{emptypage}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{xcolor}
% Some shortcuts
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\R{\ensuremath{\mathbb{R}}}
\newcommand\Z{\ensuremath{\mathbb{Z}}}
\renewcommand\O{\ensuremath{\emptyset}}
\newcommand\Q{\ensuremath{\mathbb{Q}}}
\renewcommand\C{\ensuremath{\mathbb{C}}}
\newcommand{\p}[1]{#1^{\prime}}
\newcommand{\pp}[1]{#1^{\prime\prime}}
% Easily typeset systems of equations (French package) [like cases, but it aligns everything]
\usepackage{systeme}
\usepackage{lipsum}
% limits are put below (optional for int)
\let\svlim\lim\def\lim{\svlim\limits}
\let\svsum\sum\def\sum{\svsum\limits}
%\let\svlim\int\def\int{\svlim\limits}
% Command for short corrections
% Usage: 1+1=\correct{3}{2}
\definecolor{correct}{HTML}{009900}
\newcommand\correct[2]{\ensuremath{\:}{\color{red}{#1}}\ensuremath{\to }{\color{correct}{#2}}\ensuremath{\:}}
\newcommand\green[1]{{\color{correct}{#1}}}
% Hide parts
\newcommand\hide[1]{}
% si unitx
\usepackage{siunitx}
\sisetup{locale = FR}
% Environments
% For box around Definition, Theorem, \ldots
\usepackage{mdframed}
\mdfsetup{skipabove=1em,skipbelow=0em}
\theoremstyle{definition}
\newmdtheoremenv[nobreak=true]{definition}{Определение}
\newmdtheoremenv[nobreak=true]{theorem}{Теорема}
\newmdtheoremenv[nobreak=true]{lemma}{Лемма}
\newmdtheoremenv[nobreak=true]{problem}{Задача}
\newmdtheoremenv[nobreak=true]{property}{Свойство}
\newmdtheoremenv[nobreak=true]{statement}{Утверждение}
\newmdtheoremenv[nobreak=true]{corollary}{Следствие}
\newtheorem*{note}{Замечание}
\newtheorem*{example}{Пример}
\renewcommand\qedsymbol{$\blacksquare$}
% Fix some spacing
% http://tex.stackexchange.com/questions/22119/how-can-i-change-the-spacing-before-theorems-with-amsthm
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=\parskip \thm@postskip=0pt
}
\usepackage{xifthen}
\def\testdateparts#1{\dateparts#1\relax}
\def\dateparts#1 #2 #3 #4 #5\relax{
    \marginpar{\small\textsf{\mbox{#1 #2 #3 #5}}}
}

\def\@lecture{}%
\newcommand{\lecture}[3]{
    \ifthenelse{\isempty{#3}}{%
        \def\@lecture{Lecture #1}%
    }{%
        \def\@lecture{Lecture #1: #3}%
    }%
    \subsection*{\@lecture}
    \marginpar{\small\textsf{\mbox{#2}}}
}
% Todonotes and inline notes in fancy boxes
\usepackage{todonotes}
\usepackage{tcolorbox}

% Make boxes breakable
\tcbuselibrary{breakable}
\newenvironment{correction}{\begin{tcolorbox}[
    arc=0mm,
    colback=white,
    colframe=green!60!black,
    title=Correction,
    fonttitle=\sffamily,
    breakable
]}{\end{tcolorbox}}
% These are the fancy headers
\usepackage{fancyhdr}
\pagestyle{fancy}

% LE: left even
% RO: right odd
% CE, CO: center even, center odd
% My name for when I print my lecture notes to use for an open book exam.
% \fancyhead[LE,RO]{Gilles Castel}

\fancyhead[RO,LE]{\@lecture} % Right odd,  Left even
\fancyhead[RE,LO]{}          % Right even, Left odd

\fancyfoot[RO,LE]{\thepage}  % Right odd,something additional 1  Left even
\fancyfoot[RE,LO]{}          % Right even, Left odd
\fancyfoot[C]{\leftmark}     % Center

\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\usepackage{tikz}
\newcommand{\tl}[1]{\widetilde{#1}}
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{myStyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    extendedchars=\true
}

\lstset{style=myStyle}

\lstset{language=Python}
\begin{document}
    \maketitle

    \section{Введение}

    В современном мире не представить вычислительный узел без операционной системы.

    \begin{example}
        Супермаркет с одной кассой и тремя покупателями:
        \begin{itemize}
            \item с водой, человек очень хочет пить
            \item корзинка на ужин
            \item тележка на неделю
        \end{itemize}

        Если пропустим вперёд парнишку, его вклад будет крайне маленький. Но он выйдет из магазина и проходящий может зайти увидев очередь из двух человек.

        Если же выстроить наоборот, то новые покупатели не заходят заходить в ваш супермаркет.

        Хочется иметь монополию на власть в смысле порядка очереди

        Многие процессы связаны с социальными процессами.
    \end{example}

    \begin{definition}
        Операционная система -- базовое системное программное обеспечение, управляющее работой вычислительного узла и реализующее универсальный интерфейс между аппаратным обеспечением, программным обеспечение и пользователем.

        базовое -- первое, что появляется и последнее, что умирает

        системное -- само пользу конечному пользователю не приносит, но без него не работает прикладное

        управляет -- достигает некоторых целевых показателей
    \end{definition}
    \chapter{Этапы эволюции ПО}
    \section{Программы-диспетчеры}
    Конец сороковых, компьютеры работают строго по архитектуре Фон-Неймана. Есть устройство ввода и вывода.

    4 принципа:
    \begin{itemize}
        \item однородность памяти -- код и данные в единой памяти
            \item адресность -- оперативная память это линейно-адресуемое пространство и мы можем обратиться в любой момент к любой её ячейке.
            \item программное управление -- программа представляет собой набор инструкций в память. Процессор по ходу своей работы поочерёдно берёт и на такте выполняет следующую инструкцию
            \item кодирования -- всё, и данные, и инструкции, кодируются с помощью двоичного кода.
    \end{itemize}

    \begin{problem}
        [Повторное использование кода. Автоматизация загрузки и  линковки]

        В те времена комп часто использовался для физических вычислений. Операторы заметили, что заново вводят одни и те же инструкции по многу раз. А почему бы не попробовать вынести куда-то.

        Идея: вынести ``подпрограмму'' в конкретный адрес. МЫ переходим в него из своего кода.. но как вернутся, а ещё передать что-то хочется.

        Появляются диспетчеры, которые управляют таким выводом
    \end{problem}
    \begin{problem}
        [Оптимизация взаимодействия с устройствами ввода-вывода]

        В классической архитектуре все устройства работают с памятью через процессор. Задача подкачки довольно простая, для неё не нужно всей мощности процессора. 

        Задача: осветлить картинку. Задача, которую можно делать незавсимо для всех пикселей

        Идея: контроллер -- связан с памятью, RAM и частично с процессором.

        Предсказать время подкачки нельзя, потому что совершенно разные носители с разными гарантиями. Код не может знать подкачались ли уже данные или нет. А хочется уметь на это реагировать, т.е. ждать пока завершится процесс подкачки.

        Обработчик прерываний -- меняет значение флага, опрашиваемый в бесконечном цикле, пока контроллер не даст флаг, что всё сделано. Функционал диспетчера разрастется, теперь умеет обрабатывать прерывания.

        SPOOL -- simultaneous operation online
    \end{problem}

    \begin{definition}
        Перывание -- сигнал, поступающий от внешнего устройства к центральному процессору, приостанавливающей исполнение текущего потока команд и передающий управление обработчикe прерываний.
    \end{definition}

    \begin{problem}
        [Однопрограммная пакетная <..>]
        
        Одно приложение -- много программ. Кроме того может ещё набор констант.

        Появляется термин пакет -- как совокупность программ.

        Пока исполняем одну, можем загружать другую или даже другие и тут возникает вопрос: вот мы завершли один процесс, а какой исполнять следующим. Возвращаемся к задаче про супермаркет. Если взять идею пропускать маленького и реализовать её вот так втупую, то мы рискуем попасть в программное голодание, когда постоянно подгружается что-то маленькое и проходит вперёд.

    \end{problem}

    \section{Мультипрограммные операционные системы}

    Что привело к их появлению: программы становятся более сложными и разнообразными. Неэффективно используем ресурсы, потому что исполняем программы от начала до конца.

    Идея: несколько программ можно исполнять параллельно. Простая идея привела к огромным сложностям.

    Программы обычно исполняются ``псевдо-параллельно''

    \begin{problem}
        [Обеспечение разделения времени процессора]

        Сделал аппаратное решение, будет генерироваться прерывание каждый тайминг, которое будет запускать планирование того, что выполнять следующим.

        Когда мы останавливаем процессор, в регистрах что-то есть и это что-то нужно. Идея: откатываться назад, но непонятно насколько, может я давно что-то туда положил. Забыть тоже нельзя, код дальше расчитывает на эти регистры. Регистровый контекст приходится где-то сохранять (чтобы его потом найти), подгружать такой  же контекст от другого процесса и запускать его.
    \end{problem}
\begin{figure}[!ht]
    \centering
    \incfig{pseudo-parallel}
    \caption{pseudo-parallel}
    \label{fig:pseudo-parallel}
\end{figure}
    \begin{problem}
        [Обеспечение разделения памяти]

        Когда мы пишем код, переменные заменяются на адреса. Программный ноль совпадал с реальным и всё было хорошо. Но у нас много программ и память может быть где угодно. Идея: виртуальная память -- при сиполнении подменять виртуальные адреса, считающие, что они в реальном нуле, на физические.
    \end{problem}

    \begin{problem}
        [Обеспечение защиты данных программы от деятельности других программ]

        Люди пишут код с ошибками -- закон вселенной. Если программы многих людей, а мы своей ошибкой зашли в код чужой программы, то будет нехорошо.

        Идея: защита памяти. аппаратное решение -- при обращении к памяти понимать свой-чужой.

        Но теперь не может работать наш диспетчер, он же должен быть изолированным. А ему нужно что-то взять, куда-то записать..

        Идея: кому-то нужно разрешить. Привилегированный режим. Грубо говоря отключаем защиту памяти. Этот привилегированный режим приводит к пониманию современной системы:

        System call -- обращение пользовательской программы к ядру ОС с требованием предоставить ресурс или выполнить привилегированную операцию.

        Теперь OS -- универсальный интерфейс. У неё монопольная власть, на уровне неё мы пытаемся эффективно использовать ресурсы
    \end{problem}

    \begin{problem}
        [Планирование выполнения программ и использования рускрсов]

        У каждого контроллера своя очередь, у каждого жёсткого диска своя очередь, у сетевого узла, у процессора, ... А они ещё и связаны друг с другом

        Хочется максимально эффективно всё заменеджить, что суммарно всё максимально быстро исполнилось.

        Очередь и ре<..>

        \begin{example}
            Хотим напечатать что-то на принтере. Передаём данные, прервались, перключились на другую программу, а она тоже хочет печатать.. Неразделяемый ресурс.

            Идея: ставим блок, чтобы только первый мог давать данные.

            Но может быть дедлок.. 1 захватит ресурс 1, 2 захватит ресурс 2, в какой-то момент они хотят получить другой ресурс, не отжав первый -- тупик.. Дейкстра занимался этим лет 15.
        \end{example}
    \end{problem}

    \begin{problem}
        [Универсальный доступ к информации на внешних устройствах] 

        Линейная адресация $\to $ файл, каталог
    \end{problem}
    \begin{problem}
        [Обеспечение коммуникации между программами]

        Комфортная работа множества программ, а что если они будут передавать друг-другу данные.

        ctrl+C ctrl+V -- использование буффера, требует ручного управления.

        Сигналы, передача из stdout одного в stdin в другого, ..

        Появляется понятие виртуальной машины -- приложение живёт отдельно и не знает, что есть другие приложения. С этим понятием появляется и термин операционной системы. Теперь делегирование всех операций лежит именно на ОС.
    \end{problem}

    С первой ОС сложно, не понятно кого считать уже ОС.

    1963 -- компьютер B5000 с ОС MCP -- Master Control Programm

    \section{Сетевые операционные системы}

    Компьютеры тогда -- только большие и очень дорогие компьютеры.

    Затраты на доставку программного кода до машины начинают превалировать

    АМ -- амплитудная модуляция, FM -- частотная модуляция. Способы обозначть 0 или 1 в синусоиде.

    Модем -- модулятор-демодулятор. Теперь проблемы с безопасностью. Раньше был один конкретный подконтрольный оператор, с которого можно было в случае чего спросить. А теперь надо защищаться от людей. Появляются понятии учётной записи, аутентификации.

    Появляются компании, специализирующиеся на предоставлении компьютерного времени. У такой компании могло быть уже несколько компьютеров.

    Могла быть большая нагрузка в Чикаго и простаивать компьютер в Бостоне. Тогда строили линию АТМ между Чикаго и Бостоном, чтобы перенаправлять звонки.
    
    \section{Универсальные операционные системы}
  
    Мотивация: в 60-х все ОС были платформозависимые, невозможность повторного использования кода.

    Идея: создать универсальную ОС на любую платформу

    Парадокс: чтобы разрабатывать под такую ОС, на ней должен быть компилятор языка высокого уровня

    Платформа переносимая, она сама написана на языке высокого уровня

    В решении участвовалось подразделение компании AT\&T -- Bell Labs

    Открыли реликтовое излучение, изобрели транзистор, открыли фотоэффект, матрица, ``Математическая теория связи''

    MULTICS -- привязана жёстко к набору платформ. multiplexed

    UNICS -- uniplexed. Пишется полностью на ассемблере. Первая редакция запускается 01.01.1970

    В 70 продолжаются разработки и разрабатывается язык B -- интерпретируемый язык. UNICS переписывается на B

    Керниган и Ричи разрабатывают C, встраивают его компилятор в UNICS (который ещё на B)

    конец 75 -- ed.4 ядро на C

    Первая универсальная система

    ed.7 1978 -- последняя редакция UNICS, в ней появляется bash

    В дело вступает антимонопольная служба США. AT\&T весь код передала  университет (первым -- Бэркли). UNICS $\to$ UNIX.

    Бэркли создаёт дочернее предприятие BSD (- software distribution)

    Free BSD, Open BSD, ...

    MIT, Barkley, Stanford -- три университета

    SUN (stanford university network), SUN OS ..  Solaris

    Проблема: коммерческие юниксы начинают патентовать решения. BSD лицензия защищает только имя автора. Многие пользовались этим, чтобы закрывать для других целые направления развития ОС

    Манифест Столлмана -- 4 свободы (0,1,2,3) программного изучения: использовать, изучать\&адаптировать, распространять копии, публиковать

    \copyright $\to $ \textcopyleft

    Gnu is Not Unix

    gcc -- gnu c compiler

    Студент Хельнского университета начинает интересоваться MINICS и преобразовывать. Появляется новая неожиданно-популярная система. Таненбаум делает пост: Линукс устарел

    Студент -- Линус Торвальдс.

    ему остаётся только доказать, что его система качественная. Столлман предлагает ему подключится к GNU. Линус соглашается, но с условием, что GNU переименуется в GNU/Linux -- 1983-4

    1989 -- NeXT создаёт ОС NeXTSTEP

    1997 -- Darwin $\to $ MacOS. Apple хочет выйти на рынок компьютеров и покапает NeXTSTEP вместе со всем, что у неё есть. Что-то добавляет из FreeBSD, что-то сами дописывают.

    Уровни:
    \begin{itemize}
        \item Функциональные -- с позиции пользователя
        \item Информационная -- потоки данных, структурированные информационные объекты
        \item Системная -- интерфейсы: аппаратные, пользовательские, ..
        \item Программная -- ООП, функциональная, ...
        \item Данных
    \end{itemize}
    
    \begin{definition}
        Цель ОС -- обеспечить производительность надёжность и безопасность исполнения пользовательского ПО, эксплуатации железа, хранения и передачи данных и диалога с пользователем.
    \end{definition}

    Функции ОС:
    \begin{itemize}
        \item Управление разработкой и исполнением ПО
            \begin{itemize}
                \item API
                \item Управление исполнением
                \item Обработка и обнаружение ошибок
                \item Доступ к устройствам I/O
                \item Доступ к хранилищу
                \item Мониторинг ресурсов
            \end{itemize}
        \item Оптимизация использования ресурсов. Хотим много всего, что противоречит друг с другом. Критериальные задачи $\hat K = \alpha K_1 + \beta K_2 + \gamma K_3$

            Real-time ОС - гарантируется время отлклика. Представим самолёт. При посадке ему нужно открыть закрылки. Если слишком сильно -- мы перелетим,  слишком слабо -- упадём. Бортовому компьютеру нужно быстро посчитать этот угол.

            Условный критерий $\hat K = \alpha K_1 + \beta K_2|_{K_3>z}$
        \item Поддержка эксплуатации. ОС должна иметь средства диагностики и восстановления на случай, когда железо ломается (inevitably происходит). Любая ОС умеет откатываться к последней удачной конфигурации.
        \item Поддержка развития самой ОС. ОС живёт дольше программного и аппаратного обеспечения. Может содержать ошибки и уязвимости..
    \end{itemize}

    Подсистемы:
    \begin{itemize}
        \item Управления процессами
            \begin{itemize}
                \item Дескрипторы (PCB)
                \item Планировщики. Для разных типов ресурсов выстраивают оптимальную очередь
            \end{itemize}

        \item Управления памятью
            \begin{itemize}
                \item Виртуальная память
                \item Защита памяти
            \end{itemize}
        \item Усправления файлами
            \begin{itemize}
                \item Символьные имена $\to $ физические адреса
                \item Управление каталогами
            \end{itemize}
        \item Упрваление внешними устройставмаи
            \begin{itemize}
                \item Драйвера. Устройств сотни тысяч, для каждого должна быть подпрограмма,  которая знает как с ним работать.

                   \item Plug\&Play (Plug\&Pray)
            \end{itemize}
        \item Защита данных
            \begin{itemize}
                \item  Аутентификация и авторизация
                \item аудит
            \end{itemize}
        \item API
            \begin{itemize}
                \item Разработка ПО
                \item Исполнение ПО
            \end{itemize}
        \item Пользовательский интерефейс
            \begin{itemize}
                \item CLI
                \item GUI
            \end{itemize}
    \end{itemize}

    Вопрос: Что будет в ядре стал главным. Почему? Привелигированный режим, резидентность ядра (не меняет адреса после загрузки)

    Принципы ОС:
    \begin{itemize}
        \item Модульная организация (в любом сложном ПО такое есть)
        \item Функциональная избыточность -- функционал ОС существенно больше реального сценария её использования. Удобно для разработки, не удобно для эксплуатации
        \item Функциональная избирательность -- всегда есть способ сохранить из всего многообразия функций только те, которые нужны для конкретного сценария.
        \item Параметрическая универсальность -- при разработке нужно максимально не загонять себя в константные рамки
    \end{itemize}

    \section{Поддержки концепций многоуровневой иерархической системы}

    Модули:
    \begin{itemize}
        \item Ядра
        \item Работающих в пользовательском режиме
    \end{itemize}

    \subsection{Монолитная Архитектура}

    Все видят всё. Преимущества производительности.

    Три слоя:
    \begin{itemize}
        \item main program (software)
        \item Services
        \item Utilities (hardware)
    \end{itemize}

    Хорошая модель пока немного не очень сложного кода. Потом стало понятно, что три слоя это мало.

    \subsection{Многослойная архитектура}

    Не отдельная архитектура, а скорее концепция

\begin{figure}[!ht]
    \centering
    \incfig{many}
    \caption{many}
    \label{fig:many}
\end{figure}

\subsection{Микроядерная архитектура}

Часть слоёв вынесется в пользовательский режим.

Удобно: абстрагирование через системные вызовы, часть отдаём в подкачку и экономим память

Неудобно: небезопасно, в подкачке что-нибудь можно заменить и при подкачке оно исполниться как часть ОС; могут возникать проблемы с дедлоками и прочими тупиками.

Линукс -- монолитное, но модульное ядро. 

\section{Процессы}
\begin{definition}
    совокупность набора исполняющихся команд, ассоциированных с ним ресурсов и контекста исполнения, находящиеся под управлением операционной системы.

    запускаем программу -- последовательно исполняем набор команд. Если запустить вим в двух разных терминалах, это будут те же наборы команд, но разные процессов.

    Поэтому ещё добавляет ассоциированные ресурсы. Но и здесь не ставят точку. Код ядра будет выполнятся в контексте вашего процесса. Есть стек пользователя и стек ядра. Ещё есть регистровый контекст, который сохраняется при переключении процессов. команды + ресурсы + контекст

    И наконец важно, что процессом управляет операционная система
\end{definition}

PCB -- дескриптор процесса
\begin{itemize}
    \item 
    \begin{itemize}
        \item PID -- process identificator
        \item PPID -- parent PID
        \item UID -- User ID
        \item ...
    \end{itemize}
    \item ресурсы
    \item история использования ресурсов
\end{itemize}

\begin{definition}
    Процесс -- множество потоков

    Поток -- совокупность набора исполняющихся команд и контекста исполнения, находящиеся под управление операционной системы и разделяющие ресурсы некоторого процесса.

    Поток -- тоже находится под управление ОС. Планированием ОС занимается на уровне потоков.

    Раз ОС занимается переключеним потоком, значит она умеет  сохранять контекст конкретного потока.

    Если потоков много, то возникает ограничение на их количество. Очень сложно прогнозировать правильное количество потоков. Двух уровней мало, не можем управлять распределением времени на потоки
\end{definition}

\begin{definition}
    fiber (light-weight thread) (волокно в нити -- thread'е) -- набор команд, разделяющий ресурсы и контекст исполнения одного потока и находящийся под управлением пользовательского приложения.

    Куча вопросов, а чего мы хотим? Не будет занимать в пространстве ядра никаких структур.

    Кооперативная многозадачность облегчённых потоков. Внутри волокон есть безусловные переходы, вызывающие планировщик, чтобы он решил выполнятся дальше или нет.

    Поток в Erlang -- fiber.

    Корутина.
\end{definition}

Но этих трёх уровнях всё ещё мало

\begin{note}
    Хром создаёт процессы отдельно для вкладок. Но даже если их там, 200, другие приложения не помирают, получая $\frac{1}{200}$ ресурсов
\end{note}

\begin{definition}
    job / C(ontrol)Group -- настраивание квот. На количество подпроцессов, на интернет-трафик, ...
\end{definition}

Процесс:
\begin{itemize}
    \item  Создание процесса
    \item Обеспечение ресурсами
    \item Изоляция
    \item Планирование
    \item Диспетчеризация
    \item Межпроцессное взаимодействие
    \item Синхронизация
    \item Завершение
\end{itemize}

\subsection{Создание}

Создать процесс -- создать стркутуры данных -- ProcessControlBlock. В любой операционной системе процесс порождается другим процессом. Часто создание процесса называют рождением.

В Линуксе процессы образуют дерево и порождаются клонированием. Начальный процесс, PID = 1, init/systemd. Как создаётся первый процесс.. сложно, оно часто выглядит как набор костылей. у начального процесса PPID = 0. Есть два процесса, у которых PPID = 0: PID = 1, PID = 2, два дерева: пользовательские и ядерные процессы.

Чтобы завершить процессы, должны завершиться все его потомки.

\begin{note}
    Зашли в баш по ssh, запустили веб-сервер. Хотим закрыть баш, но оставить сервер, ради которого мы собственно и зашли. Для такого есть механизм процессов-демонов. При завершении работып процесса-родителя, процесс переподвесился выше.
\end{note}

    Если процесс завершился аварийно, и его дети не успели получить код завершения, они подвешиваются выше, чтобы код завершения уже их кто-нибудь прочитал.

    ctrl+C -- послать сигнал завершения

    ctrl+Z -- послать сигнал SYGSTOP

    Если у приостановленного процесса завершился подпроцесс, от него осталась строка в таблице с его PID'ом и кодом завершением. А PID'ы штуки конечные. А если они закончатся, то даже команду kill нельзя будет послать, потому что это отдельные процесс. Такой подпроцесс называется зомби, а описанная ситуация -- зомби-апокалипсис.

    Порождение клонированием: fork (полная копия адресного процесса, со всеми ресурсами (указателями на их дексрипторы), подменяется значение PID), подменяется код на код подпроцесса.

    Такая система не позволяется подпроцессу иметь большие права, чем сам процесс, потому что он их наследует, копирует

    В Windows ситуация другая почти с начала: Есть Диспетчер/Менеджер процессов. Каждый процесс создаётся им. Может быть больше прав у дочернего процесса

Самая простая модель: два состояния: ожидание и исполнение. При рождении он попадает в ожидание.

\begin{figure}[!ht]
    \centering
    \incfig{2states}
    \caption{2states}
    \label{fig:2states}
\end{figure}

Проблемы: процессы с исключениями не умирают сразу (для обработки ошибок) и иногда пытаются сделать то же самое (деление на ноль например) много раз, чем съедают ресурсы. Новое состояние -- готовность

\begin{figure}[!ht]
    \centering
    \incfig{manystates}
    \caption{manystates}
    \label{fig:manystates}
\end{figure}

\section{Планирование}

Планировать один шаг плохо, планировать надолго тоже много

\begin{figure}[!ht]
    \centering
    \incfig{plans}
    \caption{plans}
    \label{fig:plans}
\end{figure}

Критерии алгоритмов: справедливости, эффективность. Решения оптимальные по обоим критериям совпадают только если все процессы равны.

Новые критерии: полное время исполнения. Например при компиляции чего-нибудь большого хочется побыстрее получить результат и не важно что там по справедливости и ресурсам с другими процессами

Ещё один: для пользователя важно, чтобы не было ожидания

Последний: для пользователя важно время отклика. Например когда набираешь в vim'е хочется видеть каждую буковку по мере того как она печатается, хотя с точки зрения ресурсов хорошо буфферизировать строчку и один раз её выводить.

Свойства:
\begin{enumerate}
    \item Предсказуемость -- на одинаковых параметрах одинаковый результат. 
    \item Минимальные накладные ресурсы
    \item Масштабируемость. .
\end{enumerate}

Параметры планирования:
\begin{itemize}
    \item Статические параметры системы -- не поменяются в этом экземпляре ОС
    \item Динамические параметры системы -- свободные
    \item Статические параметры процесса -- не поменяются во времени
    \item Динамические процессы:
        \begin{itemize}
            \item CPU-burst
            \item I/O-burst
        \end{itemize}
\end{itemize}
 
Алгоритмы планирования:
\begin{itemize}
    \item Вытесняющие -- по сигналу можем отобрать процесс исполнения
    \item Невытесняющие -- штука начала исполняться, завершила, дала ход следующим
\end{itemize}

Первый алгоритм:  First Came -- First Served (FCFS). На деле очередь (FIFO)

CPU-bursts:
$\begin{cases}
    p_0&13\\
    p_1&4\\
    p_2&1\\
\end{cases}$ 

Если очередь $p_0 p_1 p_2$, то $T = 18\quad \tl \tau_{\text{испл}} = \frac{13+17+18}{3} = 16\quad \tl \tau_{\text{ожид}} = \frac{0+13+17}{3}  $ 

Но если $p_2 p_1 p_0\quad T = 18\quad \tl \tau_{\text{испл}} = 8\quad \tl\tau_{\text{ожид}} = 2$

RoundRobin (RR). 

$k = 4$ -- квант, по прошествии которого очередь движется.

Пусть очередь всё та же  $p_0 p_1p_2$

$T = 18\quad \tl \tau_{exec} = 11.(6)\quad \tl \tau_{wait} = 5.(6)$

$k = 1\quad \tl \tau_{exec} = 10\quad \tl \tau_{wait} = 4$

\begin{figure}[!ht]
    \centering
    \incfig{rr}
    \caption{rr}
    \label{fig:rr}
\end{figure}


Shortest Job First (SJF) -- обычно вытесняющее по кванту. Понятно что делает

Гарантированное планирование:
\begin{itemize}
    \item $N$ -- количество процессов
    \item  $T_i$ -- время процесса в системе
    \item  $\tau_i$ -- время исполнения процесса
\end{itemize}

$\tau_i \sim \frac{T_i}{N}$ 

$R_i = \frac{\tau_i}{\frac{T_i}{N}} = \frac{\tau_i\cdot N}{T_i}$ 

Два минуса:
\begin{itemize}
    \item  Не очень устойчив к ``взлому''. Можно сделать так, чтобы твой процесс пропускали вперёд
    \item коэффициент вещественный. Постоянно упорядочивать вещественные числа.. ну такое
\end{itemize}

На идею посмотрели и отложили лет на 20.

\begin{example}
    Есть вебсервер и СУБД. СУБД не распараллелена и становиться усзким местом. Хочется, чтобы ОС поняла, что СУБД очень нужна.
\end{example}

Многоуровневая очередь.

Давайте зафиксируем возможное количество приоритетов. Давайте раздавать процессам приоритеты. Очевидно они могут совпасть. Внутри одного приоритета сделаем Round Robin. А всего так: пока есть кто-то с меньшим приоритетом, процессы ждут.

\begin{example}
    в MIT в 1967 остановили компьютер с аптаймом 7 лет и обнаружили там процесс, который 7 лет назад был поставлен и так и не исполнился.
\end{example}

Многоуровневая очередь с обратной связью -- свзять с тем сколько процессреально тратит. Есть констанстное количество приоритетов и кванты в них увеличивающиеся с умееьшением приоритета.

Но теперь нет внешнего управления приоритетом

Хочется:
\begin{enumerate}
    \item Внешнее управление приоритетом.
    \item Эффективное использование ресурсов:
        \begin{enumerate}
            \item процесс меньше простаивает
            \item как можно быстрее покидал оперативную память
            \item Уменьшить переключения в режим ядра и переключения процессов.
        \end{enumerate}
    \item Минимизировать накладные расходы:
        \begin{enumerate}
            \item Процессорное время на исполнение самого планировщика (сами процессы хочется исполнять)
            \item Память для планировщика
        \end{enumerate}
    \item Минимизировать риски возникновения блокировок
\end{enumerate}

\begin{figure}[!ht]
    \centering
    \incfig{lock}
    \caption{lock}
    \label{fig:lock}
\end{figure}

\begin{enumerate}
    \item 
    \item SJF + изменяемые кванты переключения + раздельные очереди и алгоритм балансировки между ними
    \item целочисленная / битовая арифметика, алгоритмы за n или лучше, в идеале за константу
    \item гарантированное планирование
\end{enumerate}

\section{Конкретные планировщики}

\subsection{Планировщики Windows}

\begin{figure}[!ht]
    \centering
    \incfig{win1}
    \caption{win1}
    \label{fig:win1}
\end{figure}

32 очереди. Чем больше номер, тем больше приоритет. Нулевая выделена. 1-15 -- dynamics, 16-31 -- real time

Процесс в real-time очереди остаётся там и не меняет свою чередь. dynamic -- ОС будет своими алгоритмами менять положение.

Классы приоритетов процессов:
\begin{itemize}
    \item 24 -- Realtime
    \item 13 -- High
    \item 10 -- Above Normal
    \item 8 -- Normal
    \item 6 -- Below Normal
    \item 4 -- Idle
\end{itemize}

По умолчанию процесс попадает в очередь 8. В какой-то момент там может быть достаточно тесно. Внутри Round Robin с квантом в ~12 тиков таймера (одинаковый для всех очередей)

Уровни насыщения потоков:
\begin{itemize}
    \item +15 time critical
    \item +2 highest
    \item +1 above normal
    \item 0 normal
    \item -1 below normal
    \item -2 lowest
    \item -15 idle
\end{itemize}

Это дельты работают с ограничением по группе, т.е. $8 `+` 15 = 15$, выше он не поднимется.

Хороший процесс -- интерактивный процесс. Пользовательский ввод, ожидание на семафоре. Хочется такие поощрять. За выход из ожидания, он получает подъём в зависимости от того откуда он вышел. После этого, если он становится менее интерактивным, долго хочет что-то делать, то у него постепенно уменьшается приоритет

\subsection{Планировщики Линукса}

$O(1)\quad $ 140 очередей от -20 до 100. 100 -- real time, 40 dynamics

Внутри натуральные очереди, FIFO. Если процесс завершился, не израсходовав свой квант, он ставиться в конец очереди с этим остатком. По прошествии кванта, процесс перемещается в Non Active очередь в копии всей этой структуры. В какой-то момент кванты заканчиваются у всех процессов, даже с самым минимальным приоритетом, до них доходит. И тут мы меняем местами active и non-active структуры из 140 очередей. 

CFS -- completely fair schedule 

\begin{enumerate}
    \item вещественные вычисления нафиг
    \item по памяти хочется как-то пооптимизированнее.
\end{enumerate}

Решили вернуться к гарантированному планированию. Отказались от многоуровневых очередей! Теперь одна очередь

У каждого процесса две величины:
\begin{itemize}
    \item execution time -- время исполнения, которое уже
    \item max execution time -- сколько мы должны, т.е. сколько он стоит в очереди.
\end{itemize}

Храним очередь отсортированной по execution time. Max execution time растёт с разной скоросттью в зависимости от его хорошести (параметра NICE)

Выбирается процесс с наименьшим execution time'ом и ему даётся квант равны его max execution time. По прошествии его, у него накапливается execution time и в следующий раз он попадёт в исполнение не скоро.

\section{Синхронизация процессов}

\begin{figure}[!ht]
    \centering
    \incfig{cfs}
    \caption{cfs}
    \label{fig:cfs}
\end{figure}


\subsection{Взимоисключния}

Пролог -- критическая секция -- эпилог

Критическая секция

\subsection{Прогресс}

2 процесса находятся в race condition, когда они одновременно подошли к захвату блокировки

\subsection{Отсутствие голодания}

Может быть такая ситуация, когда два процесса по очереди забирают себе ресурс и какой-то третий процесс всегда ждёт -- голодает -- такого не хочется

\subsection{Отсутствие тупиков}

Два процесса имеют два ресурса и оба хотят получить второй, не отпуская первый.

Всё это вместе -- идеальный мир.

Пусть $P_0$ и $P_1$ находятся в race condition

\begin{enumerate}
    \item Алгоритм Замка

        \begin{lstlisting}
            shared int lock = 0;

            Pi{ ...
                while(lock);
                lock = 1;
                critical section
                lock = 0;
                ...}
        \end{lstlisting}

        Между while и lock = 1 может произойти прерывание и мы попалём в критическую секцию с двух процессов

    \item Строгое чередование

    \item Флаги готовности


\end{enumerate}

\subsection{Алгоритм Петерсона (алгоритм взаимной вежливости)}

\begin{lstlisting}
    shread int ready[2] = {0,0}
    shared int turn = 
\end{lstlisting}

\begin{definition}
    Множество процессов находится в тупиковой ситуации, если каждый процесс из множества ожидает событие, которое может вызвать только другой процесс из этого же множества.
\end{definition}

\begin{theorem}
    [Кофман]

    Тупиковая ситуация возникнет при одновременных 4 условиях:
    \begin{enumerate}
        \item Mutual Exception -- невозможность двум процессам держать один и тот же ресурс
        \item Hold \& Wait -- процесс может удерживая ресурсы запрашивать другие ресурсы (по другому: пересекаются критические области)
        \item No Preemption (условие неперераспределяемости) -- ресурс, который выделен процессу может освободить только сам процесс
        \item Circular Wait -- существует кольцевая цепь процесс, в которой каждый процесс ждёт доступа к ресурсы, удерживаемому другим процессом
    \end{enumerate}

    А что делать при нарушении одного из этих условий Кофман не сказал..
\end{theorem}

Пути:
\begin{itemize}
    \item игнорировать
    \item предотвращать
    \item ищем и исправляем
\end{itemize}

Большинство ОС: предотвращают по максимуму, но все не могут. Каждая старается уменьшить вероятность возникновения каждого из условий.

Попытки решения:
\begin{enumerate}
    \item процесс может кидать задачу в очередь, не ожидая отклика от, допустим, принтера.
    \item Берём сразу все ресурсы, которые нам нужны. Если какой-то не дали, нужно всё отдать. Это не всегда можно.
    \item Можем у спящего процесса отобрать ресурс, который он держит, передать другому и потом вернуть как будто и не отбрали. Это тоже ограниченно можно делать, например если блокировка только на чтение
    \item Нумеруем все ресурсы натуральными числами. Разрешаем любому ресурсу брать следующий ресурс только если у него номер больше, чем у всех ресурсов, которые он уже взял. Периодически мы перенумеровываем ресурсы и это обеспечивает выполнение кого-нибудь. Звучит как огромные расходы, но зато есть гарантия.
\end{enumerate}

\begin{problem}
    [Проблема читателей и писателей]

    Два процесса попеременно читают так, что всегда хотя бы один читает. Один процесс хочет записать, но ему никогда не дают

    Заводим очередь. Периодически даём шанс записям и блокируем новые чтения.
\end{problem}






\end{document}

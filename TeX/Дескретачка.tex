\documentclass{book}
%nerd stuff here
\pdfminorversion=7
\pdfsuppresswarningpagegroup=1
% Languages support
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
% Some fancy symbols
\usepackage{textcomp}
\usepackage{stmaryrd}
% Math packages
\usepackage{amsmath, amssymb, amsthm, amsfonts, mathrsfs, dsfont, mathtools}
\usepackage[bb=boondox]{mathalfa}
\usepackage{cancel}
% Bold math
\usepackage{bm}
% Resizing
%\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
% Optional font for not math-based subjects
%\usepackage{cmbright}

\author{Коченюк Анатолий}
\title{Дискретная математика }

\usepackage{url}
% Fancier tables and lists
\usepackage{booktabs}
\usepackage{enumitem}
% Don't indent paragraphs, leave some space between them
\usepackage{parskip}
% Hide page number when page is empty
\usepackage{emptypage}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{xcolor}
% Some shortcuts
\newcommand\N{\ensuremath{\mathbb{N}}}
\newcommand\R{\ensuremath{\mathbb{R}}}
\newcommand\Z{\ensuremath{\mathbb{Z}}}
\renewcommand\O{\ensuremath{\emptyset}}
\newcommand\Q{\ensuremath{\mathbb{Q}}}
\renewcommand\C{\ensuremath{\mathbb{C}}}
\newcommand{\p}[1]{#1^{\prime}}
\newcommand{\pp}[1]{#1^{\prime\prime}}
% Easily typeset systems of equations (French package) [like cases, but it aligns everything]
\usepackage{systeme}
\usepackage{lipsum}
% limits are put below (optional for int)
\let\svlim\lim\def\lim{\svlim\limits}
%\let\svlim\int\def\int{\svlim\limits}
% Command for short corrections
% Usage: 1+1=\correct{3}{2}
\definecolor{correct}{HTML}{009900}
\newcommand\correct[2]{\ensuremath{\:}{\color{red}{#1}}\ensuremath{\to }{\color{correct}{#2}}\ensuremath{\:}}
\newcommand\green[1]{{\color{correct}{#1}}}
% Hide parts
\newcommand\hide[1]{}
% si unitx
\usepackage{siunitx}
\sisetup{locale = FR}
% Environments
% For box around Definition, Theorem, \ldots
\usepackage{mdframed}
\mdfsetup{skipabove=1em,skipbelow=0em}
\theoremstyle{definition}
\newmdtheoremenv[nobreak=true]{definition}{Определение}
\newmdtheoremenv[nobreak=true]{theorem}{Теорема}
\newmdtheoremenv[nobreak=true]{lemma}{Лемма}
\newmdtheoremenv[nobreak=true]{problem}{Задача}
\newmdtheoremenv[nobreak=true]{property}{Свойство}
\newmdtheoremenv[nobreak=true]{statement}{Утверждение}
\newmdtheoremenv[nobreak=true]{corollary}{Следствие}
\newtheorem*{note}{Замечание}
\newtheorem*{example}{Пример}
\renewcommand\qedsymbol{$\blacksquare$}
% Fix some spacing
% http://tex.stackexchange.com/questions/22119/how-can-i-change-the-spacing-before-theorems-with-amsthm
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=\parskip \thm@postskip=0pt
}
\usepackage{xifthen}
\def\testdateparts#1{\dateparts#1\relax}
\def\dateparts#1 #2 #3 #4 #5\relax{
    \marginpar{\small\textsf{\mbox{#1 #2 #3 #5}}}
}

\def\@lecture{}%
\newcommand{\lecture}[3]{
    \ifthenelse{\isempty{#3}}{%
        \def\@lecture{Lecture #1}%
    }{%
        \def\@lecture{Lecture #1: #3}%
    }%
    \subsection*{\@lecture}
    \marginpar{\small\textsf{\mbox{#2}}}
}
% Todonotes and inline notes in fancy boxes
\usepackage{todonotes}
\usepackage{tcolorbox}

% Make boxes breakable
\tcbuselibrary{breakable}
\newenvironment{correction}{\begin{tcolorbox}[
    arc=0mm,
    colback=white,
    colframe=green!60!black,
    title=Correction,
    fonttitle=\sffamily,
    breakable
]}{\end{tcolorbox}}
% These are the fancy headers
\usepackage{fancyhdr}
\pagestyle{fancy}

% LE: left even
% RO: right odd
% CE, CO: center even, center odd
% My name for when I print my lecture notes to use for an open book exam.
% \fancyhead[LE,RO]{Gilles Castel}

\fancyhead[RO,LE]{\@lecture} % Right odd,  Left even
\fancyhead[RE,LO]{}          % Right even, Left odd

\fancyfoot[RO,LE]{\thepage}  % Right odd,something additional 1  Left even
\fancyfoot[RE,LO]{}          % Right even, Left odd
\fancyfoot[C]{\leftmark}     % Center

\usepackage{import}
\usepackage{xifthen}
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}
\usepackage{tikz}
\begin{document}
    \maketitle
    
    \section{Введение}
    Связаться:
    \begin{itemize}
        \item stankev@gmail.com Собирать культуру общения: указывать Фамилию, Имя
        \item Телеграм @andrewzta  (для немедленного ответа. Если нет, оно утонет).
        \item +79219034426 (для катастрофических ситуаций, ожидается, что звонить никто не будет) (ни в коем случае не писать смс)
    \end{itemize}

    Обращаться можно по методическим вопросам. Если проблема группы -- пишет староста.

    Не писать по учебно-методическим проблемам (общежитие, медосмотр, армия ..) для этого есть зам. декана Харченко (легко найти контакты в ису)

    Про отчётность будет на первой практике.

    Лекции есть в ютубе andrewzta
    \chapter{1 курс}
    \section{Фундамент}

        Множество -- неопределяемое понятие. Множество состоит из элементов. $a\in A$ а-маленькое принадлежит множеству А-большое

        $A = \{2, 3, 9\}$

        $A = \{n \mid n\text{ чётно}, n \in \N \}$ -- фильтр

        $A, B:$
        \begin{itemize}
            \item $A\cup B = \{a \mid a\in A \text{ или } a\in B\}$
            \item $A\cap B = \{a \mid a\in A \text{ и } a\in B\}$
            \item $A\setminus B = \{a | a\in A \text{ и } a\not\in B\}$
            \item $\overline{A} = \{a | a\not\in A\}$??? $U$ -- универсум

                $\overline{A} = U\setminus A$
            \item[] $A\setminus B = A\cap \overline{B}$
            \item $A \triangle B = A\oplus B = (A\cup  B)\setminus (A\cap B)$
        \end{itemize}



        \begin{note}
            Если множество -- любой набор чего-угодно возникает парадокс Рассела

            $A = \{a|a\text{ -- множество, } a\not\in a\}$
            
            Вопрос лежит ли в себе $A$? 
        \end{note}

        \begin{definition}
            [Пара]

            $A, B$ -- множества. Мы можем рассмотреть множество пар, где первый элемент из $A$, а второй из $B$

            $A \times B = \{(a,b) | a\in A, b\in B\}$

            $A\times A = A^2$
        \end{definition}

        $(A\times B)\times C = \{(x,y)|x\in A\times B, y\in C\} = \{((a,b),y) |a\in A, b\in B, y\in C\}$ 
   
        $A\times (B\times C) = \{(a,(y,z))| a\in A, y\in B, z\in C\}$
        
        $A\times B\times C = \{(a,b,c)|a\in A, b\in B, c\in C\}$

        Для простоты, здесь и далее эта операция будет считаться ассоциативной и первые две строчки будут давать то же, что третья -- множество троек.

        $A\times A\times A = A^3$
        $A^n = \begin{cases}
            A&,n=1\\
            A\times A^{n-1}&,n>1\\
        \end{cases}$

        $A^0 = \{[]\} = \{\varepsilon\}$ -- пустая последовательность.         
        \begin{example}
            $A = {2, 3, 9}$
->    
            $A\times A =\{(2,2),(2,3),(2,9),(3,2),(3,3),\ldots\}$ 
        \end{example}

        \begin{note}
            У множества есть элемента и для любого элемента из универсума, он либо входит (1 раз) либо не входит.
        \end{note}

        \begin{definition}
            Функция -- отображение, которое каждому элементу из одного множества ставит в соответветвие единственный элемент из другого множества

            $f:A\to B$ 

            График $\{(x,f(x))\}$.

            Формально будем отождествлять функцию и её график.

            $f\subset A\times B\quad \forall a\in A \exists ! b\in B\quad (a,b)\in f$
        \end{definition}

        \begin{note}
            Не путайте принадлежность и включение

            $a\in A$

            $A, B, \forall a$ (если $a\in A$, то $a\in B$) $A\subset B$

            $D_4 = \{n|n\text{ кратно } 4\}$

            $E = \{n|n\text{ чётно}\}$

            $D_4\subset E$

            $\{2, 3, 9\} \subset  \{2, 3, 4, \ldots, 9\}$

            $A\subset A$

            $\O \subset A$

            $A\subset U$
        \end{note}

        \begin{note}
            Необязательно все $b$ попадают в график.
            
            $sqr:\N \to \N $ -- только квадраты чисел
        \end{note}

        \begin{definition}
            $\forall b\in B\exists a\in A: b = f(a)$ -- сюръекция
        \end{definition}

        \begin{definition}
            $\forall a\in A \forall b\in B\quad a\neq b \implies f(a)\neq f(b)$
        \end{definition}

        \begin{note}
            Принцип Дирихле -- нет инъекции из большего в меньшее множества. Если кроликов больше, чем клеток, то какому-то кролику не хватит клетки
        \end{note}

        \begin{definition}
            Если $f$ -- инъекция и сюръекция, то $f$ -- называется биекцией

            Если между двумя конечными множествами есть биекция, то у низ равное количество элементов.
        \end{definition}

        \begin{definition}
            Два множества называется равномощными, если между ними есть дикция
        \end{definition}

        $B^A$ -- множество функций из $A$ в $B$

        $|A| = a, |B| = b\quad |A\times B| = a\cdot b\quad |B^A| = b^a$

        $|A^{\O }| = 1$ эфемерная функция, которой ничего не передать

        $\O ^A = \O , A \neq \O $

        $\O ^{\O } = 1$
       
        \begin{definition}
            $R\subset A\times B$ -- отношение (бинарное)

        \end{definition}
        \begin{example}
            $A=B=\N \quad R = \{(a,b)|a<b\}\quad R= <$

            $a\vdots b\quad 6\vdots 2\quad 6\not\vdots 5$

            $A$ = люди, $B$ = собаки, $R = \{(a,b)|a\text{ -- хозяин} b\}$
        \end{example}

        Рассмотрим 5 классов отношение на квадрате множества:
        \begin{enumerate}
            \item рефлексивные $\forall a \quad aRa$

                $RC(R)$ -- рефлексивное замыкание, включаем все пары $(a,a)$
            \item антирефлексивные $\forall a \quad \neg aRa$
            \item симметричные $aRb \implies bRa$
            \item антисимметричные $aRb, a\neq b \implies \neg bRa$

                или $aRb$ и $bRa \implies a=b$
            \item транзитивность $aRb, bRc \implies  aRc$
        \end{enumerate}
        
        \begin{definition}
            1+3+5 -- рефлексивные, симметричные и тразитивные -- называются отношениями эквивалентности. 
        \end{definition}
        \begin{theorem}
            $R$ -- отношение эквивалентности на $X$, то элементы $X$ можно разбить на классы эквивалентности так, что:

            $a$ и $b$  в одном классе $\implies  aRb$
            $a$ и $b$  в разных  классах $\implies \neg aRb$

            множество таких классов обозначается $X / R$

            $N / \equiv_3 = $
            \begin{align*}
                \{\{1,4,7,10,\ldots)\\
                        \{2,5,8,11,\ldots)\}\\
                        \{3,6,9,12,\ldots)\}\}\\
            .\end{align*}   
        \end{theorem}
        \begin{note}
            Отношение равномощности -- отношение эквивалентности.

            Классы эквивалентности -- порядки. Для конечного случая обозначаются числами
        \end{note}

        \begin{definition}
            1+4+5 -- рефлексивные, антисимметричные и транзитивные -- частичные порядки

            Множество, на котором введён частичный порядок, то оно называется частично упорядоченным. (ч.у.м -- частично упорядоченное множество, poset -- partially organised set)
        \end{definition}
        
        $R\subset X\times X$

   $X, Y, Z\quad R:X\times Y\quad S:Y\times Z$

   \begin{definition}
       Композиция отношений: 

       $T = R\circ S\quad xTy \iff \exists z: xRz \text{ и } zSy$

       т.е. есть $z$, через который можно пройти, чтобы попасть в $y$ из $x$
   \end{definition}

    \begin{note}
        $R\subseteq X\times X\quad S\subseteq X\times X$

        $R\circ S \subseteq X\times X$
        
        $R\circ R\subseteq X\times X$ -- пройти два раза по стрелкам

        $R^3 = R\circ R^2 = R^2\circ R$ -- пути длины ровно 3

        $S\circ T\circ U$ -- идём по стрлке из $S$ в $T$, а потом в $U$
    \end{note}

    \begin{definition}
        Транзитивное замыкание.

        $R^+ = \bigcup\limits_{k=1}^{\infty } R^k$

        $R^0 = \{(x,x)|x\in X\}$ -- они не включаются по дефолту в $R^+$

        $R^* = \bigcup\limits_{k=0} ^{\infty } R^k = R^+ \cup R^0$ -- если между двумя вершинами существует какой-либо путь
    \end{definition}
    \begin{note}
        Транзитивное замыкание -- транзитивно

        Пусть $xR^+y \implies x R^i y$

        Пусть $yR^+z \implies yR^j z$

        $\implies x(R^i\circ R^j)z \implies  xR^k z$
    \end{note}
    \begin{note}
        $\forall T:T$ -- транзитивно. $T\subset R \implies T^+ \subset R$
    \end{note}
    \begin{proof}
        По индукции:

        База: $R^1 \subset T$ -- дано

        Переход: $R^i\subset T \implies  R^{i+1}\subset T$

        $xR^{i+1}y \implies x(R\circ R^i)y\implies \exists z: xRz\&zR^iy \implies xTz\&zTy \implies xTy$ (по транзитивности $T$)
    \end{proof}

    \section{Булевы функции}

    $\O $ -- пустое множество. С функциями из/в него всё достаточно грустно.

    $\{unit\}$

    $void$ -- ничего, константная функция

    $\mathbb{B} = \{0,1\}$

    $f:A_1\times A_2\times \ldots\times A_n \to B$  -- функция от нескольких аргументов. Из одного, но декартового произведения

    Булева функция: $f:\mathbb{B}^n\to B$

    $n=0$ -- ноль аргументов $\mathbb{B}^0 = \{[]\}$

    $\mathbb{0}, \mathds{1}$
     
    $n=1\quad$
    \begin{table}[htpb]
        \centering
        \caption{n=1}
        \label{tab:n1}
        \begin{tabular}{c|cccc}
            x&$\mathbb{0}$&id&$\neg$&$\mathds{1}$\\\hline
        0 &0  &0  &1  &1\\
        1&0&1&0&1 \\
        \end{tabular}
    \end{table}
   \begin{note}
       Подобные таблицы называются таблицами истинности функций
   \end{note} 
    $n=2$
    \begin{table}[htpb]
        \centering
        \caption{n=2}
        \label{tab:n2}
        \begin{tabular}{cc|cccccccccccccccc}
            x&y  & $\mathbb{0}$ & $\land$   &$\not\to $  & $P_1$ & $\not\leftarrow$ & $P_2$ &$\oplus$ & $\vee$ & $\downarrow$ & = & $\neg P_2$ & $\leftarrow$ & $\neg P_1$ & $\to $ & $\uparrow$ & $\mathds{1}$ \\\hline
         0&  0&  0& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 &1  &1  &1 \\
         0&  1&  0&  0& 0 & 0 &1  & 1 &  1&  1& 0 & 0 & 0 & 0 &1  & 1 & 1 & 1\\
         1&  0&  0&  0&  1&  1& 0 &0  & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 &1  &1 \\
         1&  1&  0&  1&  0&  1& 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1\\
        \end{tabular}
    \end{table}

    С помощью стрелки Пирса ($\downarrow$) и штриха Шеффера ($\uparrow$) можно выразить любую другую: $\neg x  = x \downarrow x$

    \section{Задания булевых функций}

    Самый простой способ -- таблица истинности

    $\oplus_n$ -- $2^n$ значений. глупо их все отдельно описывать

    \begin{enumerate}
        \item Задание функции формулой.

            Определим базисные функции, систему связок

            например: $\land, \vee, \neg, \oplus$

            $x_1 \oplus x_2 \oplus x_3 \ldots $

            $\{f_1, f_2, .., f_n\}$ -- базисные.

            строка -- формула. $f_i(x_1, \ldots, x_k)$ -- формула

            \begin{definition}
                Дерево разбора формулы. Если у функции арность -- $k$, то у ноды будет ровно $k$ сыновей
            \end{definition}
    \end{enumerate}

    $\overline{F}$ --  функции, которые записываются формулами, используя $F$ (замыкание $F$)

    \begin{theorem}
        [Теорема о стандартном базисе] $\overline{\{\land, \vee, \neg\}} = \mathbb{B}$
    \end{theorem}
    \begin{proof}
        Рассмотрим таблицу истинности функции $f$ Она принимает $n$ аргументов и в ней $2^n$ строк

        Пусть $f\neq \mathbb{0}$. Рассмотрим строчки, в которых единицы.

        По аргументам запишем с не -- аргументы, которые 0, и без не -- те, которые 1

        $\neg x_1 \land \neg x_2 \land x_3 \land \neg x_4 \land x^5$ -- 1 на ровно одном наборе элементов. А теперь возьмём "или" по всем строкам, в которых $1$ 

        Одна такая строка называется термом. 

        Такая форма называется совершенной дизъюнктивной нормальная формой
    \end{proof}
    \begin{lemma}
        Любая функция, кроме тождественного 0  -- есть СДНФ

        $x\vee \neg x$ -- тождественный ноль
    \end{lemma}

    Напоминание о способах задания функций:

    $F\quad x_1, x_2, \ldots ,x_{n} f\in F$

    $or(and(x, not(y)),or(0,z))$. Такие формы называются формулами. По формуле можно построить дерево разбора.

    $\land, \lor, \neg$ 

    СДНФ -- дизюнкция термов, где каждый терм -- коньюнкция литералов. Совершенная --  в каждом терме есть все переменные по одному разу

    \begin{lemma}
        $\sqsupset F$ -- некоторое множество. $\overline{F} = \mathbb{BF}$

        $\sqsupset G$ -- некоторое множество функций $\forall f\in F\quad f\in \overline{G}$

        Тогда с помощью $G$ можно выразить любую функцию $\overline{G} = \mathbb{BF}$
    \end{lemma}
    \begin{proof}
        $G\to F\to \forall  \implies G\to \forall $ -- то, что нужно доказать

        фиксируем функцию $h\in \mathbb{BF}$. Она каким-то деревом разбора выражается через функции $f\in F$. Каждая функция $f$ выражается через $g\in \overline{G}$, тогда подставим выражения функций $f$ через $g$  в узлах дерева и получим выражение функции $h$ через $\overline{G}$, значит люая функция выражается через $\overline{G} \implies \overline{G} = \mathbb{BF}$ 
    \end{proof}

    \begin{example}
        $\{\oplus, \land, \mathbb{1}\}$

        $x\land y = x\land y\qquad \neg x = x\oplus 1$ -- такая запись называется полиномом жегалкина

        $x\lor y = (x\land y)\oplus x\oplus y$
    \end{example}

    $x\land y = xy\oplus y\oplus x$ -- $\land$ опускают

    $(x\oplus y)(y\oplus z) = xy\oplus y\oplus xz\oplus yz$

    $(x\oplus 1)(y\oplus 1) = xy\oplus x\oplus y\oplus 1$

    $a\land a = a$ -- идемпотентность 

    \begin{theorem}
        Любая булева функция (кроме $\mathbb{0}$) имеет каноничный полином, причём единственный (с точностью до коммутативности и ассоциативности)
    \end{theorem}
    \begin{proof}
        булевых функций от $n$ аргументов -- $2^{2^n}$

        Мономов -- $2^n$. Каждый из них мы можем взять или не взять $\implies $ всего $2^{2^n}-1$, -1 из случая, где мы рассматриваем пустую сумму.

        Есть инъекция из булевых функций в полиному Жегалкина. Это инъеция между равномощными множествами $\implies $ это биекция.
    \end{proof}

    \section{Линейный функции}

    Полиному Жкгалкина, в которых нету $\land$

    $x\oplus y\quad x\oplus y\oplus 1$

    \begin{definition}
        Функция называется линейной, если её канонический полином Жегалкина не сожержит $\land$
    \end{definition}

    \begin{statement}
        Если $F$ содержит только линейный функции, то и $\overline{F}$ содержит только линейный функции
    \end{statement}
    \begin{proof}
        $x_1\oplus x_2 \oplus x_3$

        $x_7\oplus x_8 = (x_1\oplus x_2\oplus x_3)\ldots$ Заменяем и получаем  всё ещё сумму переменных или $\mathbb{1}$

        Если формально, строим дерево, заменяем узлы на линейные фукнции, заменяем повторы, раскрываем скобки (пользуемся ассоциативностью $\oplus$) и получаем линейную функцию.
    \end{proof}

    \begin{statement}
        Если $F$ содержит только функции, сохраняющие $0$, то и $\overline{F}$ тоже

        аналогично для $1$
    \end{statement}

    \begin{definition}
        Функция $f$ называется монотонной $\iff $ для двух наборов $x_1, x_2, \ldots, x_{n} \quad y_1, y_2, \ldots, y_{n} $, что $x_i\leqslant y_i\qquad 0<1$

        \[
            f(x_1, x_2, \ldots, x_{n} ) \leqslant f(y_1,y_2,\ldots,y_{n} )
        .\] 
    \end{definition}

    \begin{statement}
        Из монотонных функций не выразить немонотонную
    \end{statement}
    \begin{proof}
        Доказывается индукцией по дереву разбора. Увеличили аргумента, увеличился уровень выше, выше и корень тоже
    \end{proof}

    \begin{definition}
        Функция $f$ называется самодвойственная, если

        $f(x_1, \ldots, x_{n} ) = \neg f(\neg x_1, \ldots, \neg x_{n} )$ 
    \end{definition}
        
    \begin{statement}
        Из самодвойственных функций тоже не выйти. Тоже деревом разборп
    \end{statement}
    Классы Поста:
    \begin{enumerate}
        \item $F_0$ -- сохраняющие $0$
        \item $F_1$ -- сохраняющее $1$
        \item $F_l$ -- линейные
        \item $F_m$ -- монотонные
        \item $F_s$ -- самодвойственные
    \end{enumerate}

    \begin{lemma}
        $F\subseteq F_i, i\in\{0,1,l,m,s\} \implies \overline{F}\subseteq F_i$
    \end{lemma}
    \begin{corollary}
        $\overline{F}$ -- не полно
    \end{corollary}
    \begin{theorem}
        [критерий Поста] $F$ -- полное $\iff F \not\subseteq F_i$ для всех $i\in \{0,1,l,m,s\}$
    \end{theorem}
    \begin{proof}
        $\implies $ Если нет, то все функции лежат внутри этого класса. Не будет включена $\uparrow$ например, не лежащая ни в одном классе Поста

        $\impliedby $ $f_0\not\in F_0, f_1 \not\in F_1, f_l \not\in F_l, f_m \not\in F_m, f_s \not\in F_s$

        $a(x) f_0\left(x, x, \ldots, x  \right) $

        $a\left(  0 \right) = 1$

        \begin{itemize}
            \item[a] $a(1) = 1 \implies a(x) = 1$
            \item[b] $a(1) = 0 \implies a(x) = \neg x$
        \end{itemize}
        $b(x) = f_1(x, x, \ldots, x)\quad b(1) = 0$
        \begin{enumerate}
            \item $b(1) = 0 \implies b(x) = \mathbb{0}$
            \item $b(1) = 1 \implies  b(x) = \neg x$
        \end{enumerate}

        \begin{itemize}
            \item [1a] $\mathbb{1~0}$
            \item [1b] $\mathbb{0}, \neg$
            \item [2a]  $\mathbb{1}, \neg$ 
            \item [2b] $\neg, x$
        \end{itemize}

        \begin{itemize}
            \item [1a] $\mathbb{1,0}\quad f_m(x_1, \ldots, x_{n} ) >f_m(y_1, \ldots, y_{n} )\quad x_i\leqslant y_i$ Значит первое -- 1, а второе -- 9

                $f_m(x_1, \ldots, x_{n} )\\f_m(y_1, \ldots, x_{n} )\\f_m(y_1, \ldots, x_{n} )\\ \vdots\\ f_m(y_1, \ldots, y_{n} )$

                В какой-то момент единица сменилась нулём на соседних строках

                $f(y_1, \ldots, y_{i-1}, x_i, \ldots, x_{n} )=1$

                $f(y_1, \ldots, y_{i-1}, y_i, \ldots, x_{n} )=0$

                $x_i\leqslant y_i\quad x_i\neq y_i \implies x_i = 0, y_i = 1$

                $c(z) = f_m(y_1, \ldots y_{i-1}, z, x_{i+1}, \ldots, x_{n} )$ здесь вместо x и y подставлены константы

                $c(z) = \neg z$
            \item [2b] $f_s\quad x_1, x_2, \ldots, x_{n} : f_s(x_1, x_2, \ldots, x_{n} ) = \neg f(\neg x_1, \ldots, \neg x_{n} ) = t$

                $d(z) = f_s(z^{x_1}, z^{x_2}, \ldots, z^{x_{n} })\quad x^y = \begin{cases}
                    x&, y=1\\
                    \neg x&, y= 0 \\
                \end{cases}$

                $d(0) = t, d(1) = t$

                $\begin{cases}
                    t=1 \implies d(t) = \mathbb{1}\\
                    t=0 \implies d(t) = \mathbb{0}
                \end{cases}$
        \end{itemize}
        Итак мы получили $\mathbb{1,0},\neg$

        Воспользуемся нелинейной функцией: $f_l$ среди нелинейных членов в полиноме Жегалкина выберем тот, в котором меньше всего переменных. Не умаляя общности скажем, что он выглядит как $xyu_1\dots u_k\quad k+2\geqslant 2$

        $h(x,y) = f_l(x,y,\mathbb{1}, \mathbb{1}, \ldots, \mathbb{1}i, \mathbb{0}, \mathbb{0}, \ldots\mathbb{0})$ Вместо $u_k$ подставляем $\mathbb{1}$, а вместо остальных $\mathbb{0}$

        $h(x,y)= xy[\oplus x][\oplus y][\oplus \mathbb{1}]$ -- восемь вариантов.

        Если есть $\oplus 1$, напишем $\neg$

        $xy[\oplus x][\oplus y]$       

        $xy = x\land y$

        $xy\oplus x\oplus y = x\lor y$

        $xy\oplus x\quad h(x,\neg y) = x(y\oplus 1)\oplus x = xy$

        $xy\oplus y\quad h(\neg x, y) = (x\oplus 1)y\oplus y = xy$
    \end{proof}

\section{Преобразование Мёбиуса}
$f(x_1, x_2, \ldots, x_{n} ) = x\vee y / x / y / 1$    

$a_{xy}xy \oplus a_x x \oplus a_y y \oplus a_1$

$f(x_1, x_2, \ldots, x_{n} ) = \bigoplus\limits_{\vec s \in \mathbb{B}^n} a_s \prod\limits_{i:s(i) = 1} x_i = \bigoplus\limits_{\vec s\leqslant \vec x} a_{\vec s}$

$s(i) = 1 \implies  x(i) = 1 \iff  s\& x = s \iff s\leqslant x$ (покомпонентно)

\begin{definition}
    [Доминирование]

    $\vec a \leqslant  \vec b \iff  \forall i\quad a_i\leqslant b_i$
\end{definition}

Таблица истинности:
\begin{tabular}{cccc|c}
    0&0&0&\ldots&$f_{00\ldots0}$\\
    0& 0 & \ldots & 1& $f_{00\ldots_1}$\\
     &&&&\\
     &&&&\\
    1&1&\ldots&1&$f_{11\ldots_1}$\\
\end{tabular}

$f\in \mathbb{B}^{2^n}$

$\vec a = M\vec f\quad \vec f = M\vec a$

$M_{xs} = [s\leqslant x]$

Преобразование Мёбиуса -- матрица $M = \begin{pmatrix} 1&0&0&0\\1&1&0&0\\1&0&1&0\\1&1&1&1 \end{pmatrix}$



\begin{theorem}
    Преобразование матрицы --  инволюция ($M = M^{-1}$)

    $\vec a_t = \bigoplus\limits_{x\leqslant t} f_x $
\end{theorem}
\begin{proof}
    $\bigoplus\limits_{x\leqslant t}f_x = \bigoplus\limits_{x\leqslant t}\bigoplus\limits_{s\leqslant x} a_s = \bigoplus\limits_{s,x:s\leqslant x\leqslant t}a_s = \bigoplus\limits_S [(\#x: s\leqslant x\leqslant t)\%2]a_s = a_t$

    \begin{enumerate}
        \item $s\not\leqslant t \implies  \#x = 0$
        \item $s=t \implies  \#x = 1, s=x=t$
        \item $s\leqslant t_1\quad s\neq ts$ -- нечётное число раз ксориться. $z$ различных разрядов, $z\leqslant 1\quad 2^{z}$
    \end{enumerate}
\end{proof}

\begin{example}
    $  \begin{pmatrix}1\\1\\1\\0  \end{pmatrix} $
        $a_{11}=1, a_{01}=0, a_{10}=0, a_{00} = 1$

        $xy\oplus 1$ -- штрих Шефера
\end{example}

\section{Схемы из функциональных элементов (Boolean Circuts)}

\begin{definition}
    Топологической сортировкой называется отображение $\varphi:V \to  \{1, \ldots, n\}\quad u\neq v \implies  \varphi(u)\neq \varphi(v)\quad uv\in E \implies  \varphi(u)<\varphi(v)$
\end{definition}

\begin{theorem}
    Ациклический ориентированный граф имеет топологическую сортировку.
\end{theorem}
\begin{lemma}
    Если $G$ ациклический граф, то существует вершина, из которой не выходит рёбер
\end{lemma}
\begin{proof}
    [Доказательство леммы]
    Возьмём вершину: если 

\end{proof}
\begin{proof}
    [Доказательство теоремы]

   $n=1$ дадим единственной вершине номер 1

   $n>1\quad $ возьмём вершину из которой нет рёбер , дадим ей номер n и удалим её из графа. Граф от этого не стал иметь циклов, поэтому по индукционному предположению мы можем занумеровать оставшиеся $n-1$ элементов
\end{proof}

Вершины, в которых нет рёбер называются $x_1, x_2, \ldots, x_{n} $. Дальше идут внутренние вершины, обозначаемые функциями. Например, если обозначена $\land$, то в неё входит два ребра. Если некоммутативная функция, то указывается порядок. Исходящая степень может быть любой. Завершает всё вершина выхода

\begin{figure}[ht]
    \centering
    \incfig{sceme}
    \caption{sceme}
    \label{fig:sceme}
\end{figure}

$x\oplus y = (x\land \neg y) \lor (\neg x \land y)$

Дерево разбора легко превращается в схему.
\begin{theorem}
    Не существует формулы $len(\phi) = \overset{\sim }O(n)$ для $\oplus_n$ в $\{\land, \lor, \neg\}$
\end{theorem}
В схеме мы можем пересипользовать то, что в формуле пришлось бы повторять.

$B$ -- базис

 \begin{theorem}
     Функцию $f$ можно задать формулой в базе $B \iff  f$ можно представить схемой 
 \end{theorem}

 \begin{definition}
     Сложностью функции $f$ в базисе $B\quad size_B(f) = \min$ число функциональных элементов в схеме.
 \end{definition}
 \begin{definition}
     Глубина схемы определяется рекурсивно: глубина входов -- 0, глубина вершины -- максимум из глубины входящих + 1

     depth$_B(f)$ -- минимальная глубина схемы для функции.
 \end{definition}

 \begin{theorem}
        $B_1, B_2$ -- базисы.

        $\exists c\quad\forall f\quad size_{B_1}(f) \leqslant c\cdot size_{B_2}(f)$
 \end{theorem}
 \begin{proof}
     $B_2 = \{b_1, b_2, \ldots, b_n\}$

     $b_i$ выразим через $B_1$

     $C\leqslant \max\limits_{b_i\in B_2} size_{B_1}(b_i)$

     (оптимальная схема может быть лучше, поэтому $\leqslant $)
 \end{proof}
 \begin{theorem}
     То же самое про глубину
 \end{theorem}
\begin{corollary}
    $size(f)$ без базиса -- асимптотическое поведение не зависящее от базиса (по теоремам при переходе к другому базису всё отличается в константу) 
\end{corollary}
\begin{corollary}
    $c_1 size_{B_2}(f) \leqslant size_{B_1}(f) \leqslant  c_2 size_{B_2}(f)$

    Размер функции с точностью до константы не зависит от базиса
\end{corollary}

\section{Конкретные схемы для логических операций}

Числа храниться в виде двоичного кода. Занумеруем в двух числах биты: $x_0, \ldots, x_{n}, y_0, \ldots, y_{n} $

Побитовое И -- $n$ элементов  $\land$ принимающие соответствующие разряды.

$z_0 = x_0\land y_0 \ldots z_n = x_{n} \land y_{n} $

Размер схемы: $n\quad $ глубина: 1  $\qquad size=n\quad depth=1$

Побитовое ИЛИ -- так же. Любая побитовая операция -- так же.

Арифметические операции -- не так же. Биты начинают зависеть друг от друга.

Сложение двух битов: заведём два выходных бита:  $low = a\oplus b\quad high = a\land b$. Такая схема называется неполным сумматором. Неполным, потому что из него не собрать сумматор для целых чисел. Для второго бита понадобиться сложить биты чисел и ещё бит переноса. Но сумма трёх битов, к счастью, все ещё помещается в два бита $1+1+1=3 = 11_2$

$a,b,c\quad low = \oplus_3\left( a, b, c \right)\quad high = med_3\left( a, b, c \right)  $ -- полный сумматор. Первому биту на перенос подаётся $\mathbb{0}$, а для остальных будут складываться соответствующие биты и перенос с предыдущих битов. Другое название -- линейный сумматор.

$size=n\quad depth = n$

\begin{figure}[ht]
    \centering
    \incfig{sum}
    \caption{sum}
    \label{fig:sum}
\end{figure}

\begin{tabular}{cc|cl}
    0&0& $\mathbb{0}$ &k (kill)\\
    0&1& $x$ & p (propogate)\\
    1&0& x & p\\
    1&1& $\mathbb{1}$ &g (generate)
    
\end{tabular}

\begin{tabular}{c|ccc}
    1$\backslash$ 2&k&g&p\\ \hline
    k&k&g&k\\
    g&k&g&g\\
    p&k&g&p\\
\end{tabular}
$a(bc) = (ab)c = abc$ -- композиция ассоциативна!

Схема композиции: принимает четыре значения, выдаёт два. Имеет константную глубину.

(Дальше жесть, которую я не могу нарисовать, но суть в том, что раз оно ассоциативное, то мы можем запилить двоичное дерево и делать всё за радостный логарифм.)

$size=O(n)\quad depth = O(\log n)$ -- Двоичный каскадный сумматор. Лучше сделать нельзя.

$-y = (\sim y)+1$ отрицательные числа храняться как дополнение +1

$x-y = x+(~y)+1$. Отрицание  $y$ сделать легко, но как добавить ещё $1$? Но у нас есть нулевой перенос в нулевой разряд. Давайте сделаем его $c_0=1$

\begin{tabular}{ccccccc}
    &&&1&0&1&1\\
    &&&1&1&0&1\\
    \hline
    &&&1&0&1&1\\
    &&0&0&0&0&\\
    &1&0&1&1&&\\
    1&0&1&1&&&\\\hline
\end{tabular}

Умножать двоичные числа в стлбик просто. Схема даже имеет название Матричный умножитель

Дерево Уоллиса: 
Во-первых превратим сумму трёх чисел в сумму двух. Для трёх чисел поразрядно сделаем сумматор, который будет возвращать сумму и перенос побитого. Здесь мы не передаём перенос никуда. Дальше из переносов сделаем число и из сумм сделаем число. Получим два числа и нам нужно сложить уже их.

\section{Линейные программы}

\begin{definition}
    $x_1, x_2, \ldots, x_{n} $ -- переменные

    $x_{n+1}, x_{n+2}, \ldots, x_{n+t} $ -- дополнительные $t$ переменных.

    Для базиса (например $\lor, \land, \not$):
     \begin{equation*}
     \begin{split}
         x_{n+1} &=x_2\lor x_7\\
         x_{n+2} &= \neg x_4\\
         x_{n+3} &= x_{n+1}\land x_{n+2}\\
        \vdots&\\
    .\end{split}
     \end{equation*}

    В дополнительных переменных разрешается одна функция из базиса применённая к предыдущим переменным.
\end{definition}
\begin{example}
    Сделаем $\oplus$

    $x_1, x_2$

    \begin{align*}
        x_3=\neg x_1\\
        x_4=\neg x_2\\
        x_5=x_1\land x_4\\
        x_6=x_2\land x_3\\
        x_7=x_5\lor x_6\\
    .\end{align*}

\end{example}

\begin{theorem}
    $\exists $ схема из функциональных элементов длины $t \iff \exists $ линейная программа длины $t$
\end{theorem}
\begin{proof}
    Если на схеме задать топологическую сортировку (пронумеровать так, чтобы стрелки были из меньшего числа к большему, то можно идти по полученным номерам:  сначала сделать доп. переменные от входов, потом уже зависящие не только от них, но от уже заведённых согласно схеме.

    Обратно: каждой доп. переменной соответствует применение функции (функционального элемента) к уже полученным. В этот элемент идут аргументы из определения доп. переменной, а из неё, соответственно её значение.
\end{proof}
\begin{note}
    Линейных программ больше, чем схем из функциональных переменных:

    $\begin{cases}
        x_3=\neg x_1\\
        x_4=\neg x_2\\
    \end{cases}$ и $\begin{cases}
        x_3=\neg x_2\\
        x_4 = \neg x_1
    \end{cases}$ приводят к одному результату и одной схеме, но это различные линейные программы
\end{note}

$\{\downarrow\}$ -- базис.

$n^2\cdot (n+1)^2 \cdot \ldots\cdot (n+t-1)^2\leqslant (n+t)^{2t}$

\begin{lemma}
    Схем из $t$ функциональных переменных  $\leqslant (n+t)^{2t}$
\end{lemma}

$\frac{2^n}{3n}$ Схем $ c\leqslant \left( n+\frac{2^n}{3n} \right) ^{\frac{2\cdot 2^n}{3n}} $ 

$\alpha\leqslant \frac{\left( n+\frac{2^n}{3n} \right) ^{\frac{2\cdot 2^n}{3n}} }{2^{2^n}} $ -- для функций, которые можно реализовать за $\frac{2^n}{3n}$ элементов

$\log _2\alpha\leqslant \frac{2^{2^n}}{3n}\log _2\left( n+\frac{2^n}{3n} \right) -2^n = 2^n\left( \frac{2}{3n}\log _2\left( n+\frac{2^n}{3n} \right) -1 \right) \leqslant 2^n\left( \frac{2}{3n}\cdot n-1 \right) \leqslant -\frac{1}{3}2^n $ 

$\alpha\leqslant 2^{-\frac{1}{3}2^n}\leqslant \left( \frac{1}{\sqrt[3]{2} } \right)^{2^n} \to 0, n\to \infty  $

$\exists n_0: n>n_0 \implies  n+\frac{2^n}{3n}\leqslant 2^n$ 

\begin{theorem}
    $\forall c>0 \quad g(n)\leqslant \frac{2^n}{3n}\qquad\exists n_0: n>n_0$, то (доля функций от $n$ аргументов, которые можно реализовать с помощью $g(n)$) $\leqslant c$ 

    Или (доля функций $\ldots$) $\to 0, n\to \infty $

\end{theorem}
\begin{proof}
    $f(x_1x_2\ldots x_ky_{k+1}\ldots y_{n})$

    Рассмотрим таблица, где по горизонтали указывается набор $x$-ов, а по вертикали --  $y$

    $x_1\oplus y_2\oplus y_3$
    
    \begin{tabular}{c|cccc}
       &0&0&1&1\\
       &0&1&0&1\\\hline
        0&0&1&1&0\\
        1&1&0&0&1\\
    \end{tabular}

    Разобьём таблицы на горизонтальные полосы длины $s$

    Столбцы  $a\sim_j b$ -- равны в $j$ полосе -- отношение эквивалентности

    Число полос  $p = \frac{2^k}{s}$ 

    $\exists $ не более чем $2^s$ классов эквивалентности.

    Для полосы  $j$ и маски  $m\quad g_{jm}$ -- значения маски в полосе, за её пределами --  $0$

    Теперь возьмём мультиплексор ( $n$ входов,  $2^n$ выходов,  $1$ на выходе с числом  $(x_1\ldots x_{n})_2 $). Выделим в нём полосу $j$, в неё проorим те значения, которые могут быть $1$

    $f(x_1 \ldots x_k, y_{k+1} \ldots y_{n} ) = \bigvee\limits_{j=1}^p g_{jm_j^c}$

    Суммарно: $2^{k} + 2^{k+s} + 2^{n-k} + 2^{n-k}\cdot \frac{2^k}{s} + 2^{n-k} + 2^{n-k} = O\left( 2^{k+s}+ \frac{2^n}{s} \right) $ 

    Теперь возьмём $k=\log _2 s$, а $s = n-2\log _2 n$

    $2^{k+s} + \frac{2^n}{s} = 2^{n-\log n}+ \frac{2^n}{n\cdot 2\log_2 n} = O\left( \frac{2^n}{n} \right) $


\end{proof}

\begin{definition}
    Алфавит $\Sigma$ -- любое непустое конечное множество.
\end{definition}

Последовательность символов: $\Sigma^2\quad \Sigma^3 \ldots \bigcup\limits_{k=0}^{\infty }\Sigma^k =: \Sigma^*$ -- множество всех слов (или подстрочек) над алфавитом $\Sigma$

$\Sigma^0 = \{\varepsilon\}$

$\alpha, \beta$ -- два слова.

 \begin{definition}
    $\alpha \beta$ -- конкатенация  $\Sigma^*\times \Sigma^*\to \Sigma^*$

    $\alpha\in \Sigma^k\quad\beta\in \Sigma^l\quad \gamma = \alpha\beta \in \Sigma^{k+l}$

    $\gamma[i] = \begin{cases}
        \alpha[i]&,i\leqslant k\\
        \beta[i-k]&,i>k\\
    \end{cases}$ 
\end{definition}
Свойства конкатенации:
\begin{enumerate}
    \item $(\alpha\beta)\gamma = \alpha(\beta\gamma)$
    \item  $\alpha \varepsilon = \epsilon\alpha=\alpha$
\end{enumerate}

Структуру с ассоциативностью и нейстральным элементом называют \underline{моноидом}

\begin{definition}
$\Sigma, \Pi$ -- алфавиты

    Обобщённым кодом $\phi$ называется функция  \[
    \varphi:\Sigma^* \to \Pi^*
    .\] 
\end{definition}

\begin{definition}
    Код называется \underline{декодируемым} (или однозначным), если $\alpha\neq \beta\implies \varphi(\alpha)\neq \varphi(\beta)$

    Или, что то же самое, $\varphi$ -- инъективная функция.
\end{definition}

\begin{note}
    $zip: \Sigma^* \to \Sigma^*$ -- однозначное декодируемый. Не требует, чтобы любая последовательность символов была валидным кодом, в который могло что-то зашифроваться.

    $jpeg:\Sigma^* \to \Sigma^*$ -- сжатие с потерями. Когда декодируем, получаем другой файл. Несколько файлов могут сжаться в один код.

    $png$ -- сжатие без потерь

    Транслитерация фамилий в паспорте  $A\to A\quad C\to S\quad $ Ч $\to CH$
\end{note}

\begin{definition}
    Разделяемый код: каждый символ кодирует отдельно $\varphi:\Sigma \to  \Pi^*$

    $\varphi(c_1c_2c_3\ldots c_n) = \varphi(c_1)\varphi(c_2) \ldots \varphi(c_n)$
\end{definition}

На время будем считать $\Sigma=\Pi$

 \begin{statement}
    Не существует кода $\Sigma^*\to \Sigma^*$, который не увеличивает любой текст, а некоторые уменьшает
\end{statement}
\begin{proof}
    Длины 0 меньше точно незакодировать

    Длины 1 не можем опять.

    Длины 2, опять та же проблемы, все тексты меньше уже заняты.
\end{proof}

\begin{note}
    Но $zip$ то всё сжимает..

    ( $zip$ архив точно не сожмёт дальше)
\end{note}

$S$ -- строка. Хотим построить для неё оптимальный код. Какой?

$\Sigma = \{c_1, c_2, \ldots, c_n\}\quad p_i$ -- количество вхождений $c_i$  в  $S$

$\varphi:\Sigma \to \mathbb{B}^*$ -- двоичный код. $l_i = len(\varphi(c_i))\quad len(\varphi(s)) = \sum\limits_{i=1}^{k} l_ip_i$

\begin{itemize}
    \item Префиксный код
    \item код Хаффмана
    \item неравенство Крафта-МакМиллана
\end{itemize}

\begin{definition}
    $\varphi$ -- префиксный код, если  \[
        \forall a, b\in \Sigma\quad \varphi(a) \text{ не префикс } \varphi(b)
    .\] 
\end{definition}

\begin{example}
    \begin{tabular}{cc}
        a&0\\
        b&00\\
        c&11\\
    \end{tabular}
Это не префиксный код, потому что $a$ префикс  $b$


    \begin{tabular}{cc}
        a&0\\
        b&00\\
        c&11\\
    \end{tabular}

    Это уже префиксный код

    \begin{tabular}{c|c|c|c|c|c|c|c|c}
        0&0&10&10&11&11&11&10&0\\
        a&a&b&b&c&c&c&b&a\\
    \end{tabular}
\end{example}

\begin{lemma}
    Префиксный код однозначно декодируемый
\end{lemma}

Можно строить дерево двоичного кода.
\begin{figure}[ht]
    \centering
    \incfig{tree}
    \caption{tree}
    \label{fig:tree}
\end{figure}

Сиволам, которые встречаются чаще, хотелось бы выдать меньший код
\begin{problem}
    Префиксный код, $\Sigma l_ip_i \to \min$
\end{problem}
\begin{lemma}
    [1]
    $\exists $ дерево оптимального, когда два символа с минимальным $p_i$ являются братьями на максимальной глубине.
\end{lemma}
\begin{proof}
    Рассмотрим дерево, расммотрим две минимальные вершины. Не может быть, чтобы брата не было (иначе у минимальной вершины можно было бы отрезать последний символ, оставив код префиксным.

    Если два брата соотвествуют минимальным $p_i$ -- всё.

    Если нет,  $p_i, p_j$ -- минимальные  $p_k, p_l$ -- самые глубокие

     $p_i, p_j$ -- два самых минимальных $ \implies p_j\leqslant p_k, p_j\leqslant p_l$

     $p_k, p_l$ -- два самых глубоких  $\implies l_i\leqslant l_k]quad l_j\leqslant l_l$

     $\sum_{t} l_tp_t = \sum_{t\neq i,j,k,l}l_tp_t+p_il_i+p_jl_j+p_kl_k+p_ll_l$ 

     $\sum_{t} \p l_tp_t = \sum_{t\neq i,j,k,l} l_tp_i+p_jl_k+p_jl_l+p_kl_i+p_ll_j$ 

     Их разность $= p_i(l_i-l_k) + p_j(l_j-l_l) - p_k(l_i-l_k) - p_l(l_j-l_l)$
\end{proof}
\begin{example}
    \begin{tabular}{ccc}
        a&b&c\\2&2&3\\
    \end{tabular}

    $a = x 0\quad b = x 1$

    Пусть мы объединили $a$ и  $b$  в один символ  $x$

     $aabbc c c c =x x x x c c c$

     $\sum_{a,b\to x}p_il_i = \sum_{i\neq x} p_il_i + p_xl_x = \sum_{i\neq x} p_il_i + p_a(l_a-1) + p_b(l_b-1) = \sum_{i(a,b)\text{отдельно}}p_il_i-p_a-p_b$
\end{example}

\begin{example}
    Код Хаффмана

\begin{figure}[ht]
    \centering
    \incfig{haff}
    \caption{haff}
    \label{fig:haff}
\end{figure}
\end{example}

\begin{theorem}
    [Неравенство Крафта-МакМиллана]

    $S\quad c_1\ldots c_k$

    Можно построить однозначно декодируемый двоичный код слов  $l_i$
    тогда и только тогда, когда
    \[
         \sum_{i=1}^{k} s^{-l_i} \leqslant 1
    .\] 
\end{theorem}
\begin{proof}
    \begin{itemize}
        \item []
        \item [$\impliedby $] $l_1\leqslant l_2\leqslant \ldots l_k$

            $2^{-l_1} \geqslant  2^{-l_2} \geqslant  \ldots \geqslant  2^{-l_k}$

            $2^{-l_1}+ \ldots + 2^{-l_i-1}<\frac{1}{2}\quad \times 2^{l_i}$ 
        \item [$\implies $] Пусть есть префиксный код. Запишем в листья его дерева $2^{-d}, d$ -- глубина. После этого запишем в узлах сумму детей. Тогда в корне будет  число $\leqslant 2^0=1$

            Теперь пусть его однозначно декодируемый код. 0 и 1 заменим на a и b, чтобы они не интерпретировались как числа.

            $\begin{array}{c}
                с_1\to aba\\
                c_2\to ab\\
                \vdots \to  aa\\
                c_n \to bbb\\
            \end{array}$

            Сложим их $(aba+ab+aa+bbb)^k = abaaba \ldots aba + abab\ldots ab + \ldots + bbbbbb\ldots bbb$ $n^k$ слагаемых. 

            $L = \max l_i$ максимальная длина слова в сумме --  $kL$

            Подставим  $a=\frac{1}{2}\quad b=\frac{1}{2}$ в равенство

            $(\sum 2^{-li})^k = $ длины от $1$ до  $kL$ и все слова различны

            (слова длины 1)  + (слова длины 2) + $ \ldots $ + (слова длины kL)

            Для $i$ каждое слово вычислится в  $(\frac{1}{2})^i$ и они все различны, т.е. их максимум $2^i$, значит скобка не превышает $1$

            Значит  $\left( \sum 2^{-li} \right)^k \leqslant kL \forall k$

            Если сумма слева $>1$, то там растущае экспонента и она обгонит линейно растущую, значит  сумма $\leqslant 1$, что и требовалось.
\begin{figure}[ht]
    \centering
    \incfig{отрезки}
    \caption{отрезки}
    \label{fig:отрезки}
\end{figure}


$-$
    \end{itemize}
\end{proof}

\begin{note}
    Код Хаффмана -- оптимальный префиксный $\implies $
\end{note}

Пусть есть код с буквами $a, b$ и букв  $a$ очень много

 $0\quad aaaaaaaaaa$

  $10\quad a$ 

  $11\quad b$

  \section{Арифметическое кодирование}

  $c_1, c_2, \ldots, c_n$ -- символы, которые встречаются $f_1, f_2, \ldots, f_n$ раз

  $\sum f_i =L$ -- длина текста, который мы хотим закодировать

   $p_i = \frac{f_i}{L}$ 

   $abacaba\quad p_a = \frac{4}{7}\quad p_b = \frac{2}{7}\quad p_c = \frac{1}{7}$

   Алгоритм: $l=0, r=1$ Делим в пропорциях  $p_i$-ых (порядок не важен, но должен быть одинаков у кодировщика и декодировщика) Далее берём следующую букву, выделяем соответствующий отрезок, зумимся в него и повторяем операцию, расмматривая его как изначальный.

    \begin{enumerate}
        \item $2^{-q}\leqslant r-l$

            $\impliedby -q\leqslant \log _2 (l-r)$ 

            $\impliedby q\geqslant -\log _2(l-r)$
            
            Но также $q\leqslant \left\lceil -\log _2(l-r) \right\rceil $

            $l-r = \prod_{i=1}^L pc_i = \left( \prod_{i=1}^L p_i^{p_i} \right) ^L$

            $-\log _2(l-r) = -L\log _2\left( \prod_{i=1}^{L}p_i^{p_i}\right)  = -L \sum_{i=1}^{n} p_i\log _2p_i$

            $q\leqslant \Theta L, \Theta = \sum_{i=1}^{n} p_i\log _2p_i$ -- энтропия 

   \end{enumerate}

   \subsection{RLE-кодирование}

   Running length encoding. $abbbbaaaaabbbbbb\quad 1a4b5a5b$
   \subsection{MTF-кодирование}
   Move to front

   $abbbbaaaaabbbbbccccccccaa$

   $\begin{array}{ccc}
       a&b&c\\0&1&2
   \end{array}$

   $a\to 0, b\to 1$ но мы перемещаем $b$  в начало

    $\begin{array}{ccc}
        b&a&c\\
    \end{array}$ 
    
    $b\to 0, b\to 0, \ldots, b\to 0, a\to 1, a\to 0 \ldots,b\to 1, b\to 0\ldots,c\to 2,c\to 0$

    $0100010000100002000000020$ -- резкий переход по частотам в сторону  $0$

     $\to bzip2$ -- BWT Barrows Wheeler Transform :

     $abacaba\$\quad \$$ 

      $\begin{array}{c}
          \$avacaba\\
          a\$abacab\\
          aba\$abac\\
          acaba\$ab\\
          abacaba\$\\
          ba\$abaca\\
          bacaba\$a\\
          caba\$aba\\
      \end{array}$

      последний столбец -- результат $abcb\$aaa$ 


      Text $\to $ BWT $\to $ MTF $\to $ AE/Haff

      \subsection{LZ77-78}

      $abacaba$

      $abac(4,3)$ -- отступи на 4 назад и повтори 3.

      $ababababc\quad ab(2,2)(4,4)c\qquad ab(2,6)c$

       $\begin{array}{cc}
           a&0\\b&1\\c&2\\&\\ab&3\\ba&4\\ac&5\\ca&6\\aba&7\\a\$&8\\
       \end{array}$

       $010230$
   \end{document}
